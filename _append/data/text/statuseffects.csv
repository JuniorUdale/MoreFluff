Name,Displayed As,Symbol,Description,Stacks?,Remove at End Turn?,Remove at Start Turn?,Invisible?,Blocked by Reduce?,Script: When inflicted,Script: On any status infliction,Script: Before Start Turn,Script: On Start Turn,Script: On any equipment use,Script: On any countdown reduce,Script: End Turn,Script: After Combat,Script: On damage inflicted,Script: On damage taken,Script: On status remove
regen0,Spooky_Regen,curse,spoooooooooooooooooky! if you're reading this and aren't poking|around[;] stuff has gone wrong. Contact Jackeea!,YES,NO,YES,YES,NO,,,,,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totalheal = 0; for(i in 0...13) { totalheal += getstatusself(~regen~+i);  removestatusself(~regen~+i|ALL); if(getstatusself(~regen~+(i+1)) > 0){ inflictself(~regen~+i|getstatusself(~regen~+(i+1))); };}; if (totalheal > 0 && target.hp > 0) {  sfx(~_heal~); attackself(-totalheal); };  };,,,,
regen1,Regen,regen,Restore <value> health at the end of your turn. Lasts for 1 turn.|Stacking this increases the healing[;] not duration.,YES,NO,NO,NO,NO,,,,,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totalheal = 0; for(i in 0...13) { totalheal += getstatusself(~regen~+i);  removestatusself(~regen~+i|ALL); if(getstatusself(~regen~+(i+1)) > 0){ inflictself(~regen~+i|getstatusself(~regen~+(i+1))); };}; if (totalheal > 0 && target.hp > 0) {  sfx(~_heal~); attackself(-totalheal); };  };,,,,
regen2,Regen,regen,Restore <value> health at the end of your turn. Lasts for 2 turns.|Stacking this increases the healing[;] not duration.,YES,NO,NO,NO,NO,,,,,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totalheal = 0; for(i in 0...13) { totalheal += getstatusself(~regen~+i);  removestatusself(~regen~+i|ALL); if(getstatusself(~regen~+(i+1)) > 0){ inflictself(~regen~+i|getstatusself(~regen~+(i+1))); };}; if (totalheal > 0 && target.hp > 0) {  sfx(~_heal~); attackself(-totalheal); };  };,,,,
regen3,Regen,regen,Restore <value> health at the end of your turn. Lasts for 3 turns.|Stacking this increases the healing[;] not duration.,YES,NO,NO,NO,NO,,,,,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totalheal = 0; for(i in 0...13) { totalheal += getstatusself(~regen~+i);  removestatusself(~regen~+i|ALL); if(getstatusself(~regen~+(i+1)) > 0){ inflictself(~regen~+i|getstatusself(~regen~+(i+1))); };}; if (totalheal > 0 && target.hp > 0) {  sfx(~_heal~); attackself(-totalheal); };  };,,,,
regen4,Regen,regen,Restore <value> health at the end of your turn. Lasts for 4 turns.|Stacking this increases the healing[;] not duration.,YES,NO,NO,NO,NO,,,,,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totalheal = 0; for(i in 0...13) { totalheal += getstatusself(~regen~+i);  removestatusself(~regen~+i|ALL); if(getstatusself(~regen~+(i+1)) > 0){ inflictself(~regen~+i|getstatusself(~regen~+(i+1))); };}; if (totalheal > 0 && target.hp > 0) {  sfx(~_heal~); attackself(-totalheal); };  };,,,,
regen5,Regen,regen,Restore <value> health at the end of your turn. Lasts for 5 turns.|Stacking this increases the healing[;] not duration.,YES,NO,NO,NO,NO,,,,,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totalheal = 0; for(i in 0...13) { totalheal += getstatusself(~regen~+i);  removestatusself(~regen~+i|ALL); if(getstatusself(~regen~+(i+1)) > 0){ inflictself(~regen~+i|getstatusself(~regen~+(i+1))); };}; if (totalheal > 0 && target.hp > 0) {  sfx(~_heal~); attackself(-totalheal); };  };,,,,
regen6,Regen,regen,Restore <value> health at the end of your turn. Lasts for 6 turns.|Stacking this increases the healing[;] not duration.,YES,NO,NO,NO,NO,,,,,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totalheal = 0; for(i in 0...13) { totalheal += getstatusself(~regen~+i);  removestatusself(~regen~+i|ALL); if(getstatusself(~regen~+(i+1)) > 0){ inflictself(~regen~+i|getstatusself(~regen~+(i+1))); };}; if (totalheal > 0 && target.hp > 0) {  sfx(~_heal~); attackself(-totalheal); };  };,,,,
regen7,Regen,regen,Restore <value> health at the end of your turn. Lasts for 7 turns.|Stacking this increases the healing[;] not duration.,YES,NO,NO,NO,NO,,,,,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totalheal = 0; for(i in 0...13) { totalheal += getstatusself(~regen~+i);  removestatusself(~regen~+i|ALL); if(getstatusself(~regen~+(i+1)) > 0){ inflictself(~regen~+i|getstatusself(~regen~+(i+1))); };}; if (totalheal > 0 && target.hp > 0) {  sfx(~_heal~); attackself(-totalheal); };  };,,,,
regen8,Regen,regen,Restore <value> health at the end of your turn. Lasts for 8 turns.|Stacking this increases the healing[;] not duration.,YES,NO,NO,NO,NO,,,,,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totalheal = 0; for(i in 0...13) { totalheal += getstatusself(~regen~+i);  removestatusself(~regen~+i|ALL); if(getstatusself(~regen~+(i+1)) > 0){ inflictself(~regen~+i|getstatusself(~regen~+(i+1))); };}; if (totalheal > 0 && target.hp > 0) {  sfx(~_heal~); attackself(-totalheal); };  };,,,,
regen9,Regen,regen,Restore <value> health at the end of your turn. Lasts for 9 turns.|Stacking this increases the healing[;] not duration.,YES,NO,NO,NO,NO,,,,,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totalheal = 0; for(i in 0...13) { totalheal += getstatusself(~regen~+i);  removestatusself(~regen~+i|ALL); if(getstatusself(~regen~+(i+1)) > 0){ inflictself(~regen~+i|getstatusself(~regen~+(i+1))); };}; if (totalheal > 0 && target.hp > 0) {  sfx(~_heal~); attackself(-totalheal); };  };,,,,
regen10,Regen,regen,Restore <value> health at the end of your turn. Lasts for 10 turns.|Stacking this increases the healing[;] not duration.,YES,NO,NO,NO,NO,,,,,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totalheal = 0; for(i in 0...13) { totalheal += getstatusself(~regen~+i);  removestatusself(~regen~+i|ALL); if(getstatusself(~regen~+(i+1)) > 0){ inflictself(~regen~+i|getstatusself(~regen~+(i+1))); };}; if (totalheal > 0 && target.hp > 0) {  sfx(~_heal~); attackself(-totalheal); };  };,,,,
regen11,Regen,regen,Restore <value> health at the end of your turn. Lasts for 11 turns.|Stacking this increases the healing[;] not duration.,YES,NO,NO,NO,NO,,,,,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totalheal = 0; for(i in 0...13) { totalheal += getstatusself(~regen~+i);  removestatusself(~regen~+i|ALL); if(getstatusself(~regen~+(i+1)) > 0){ inflictself(~regen~+i|getstatusself(~regen~+(i+1))); };}; if (totalheal > 0 && target.hp > 0) {  sfx(~_heal~); attackself(-totalheal); };  };,,,,
regen12,Regen,regen,Restore <value> health at the end of your turn. Lasts for 12 turns.|Stacking this increases the healing[;] not duration.  (Maximum duration!),YES,NO,NO,NO,NO,,,,,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totalheal = 0; for(i in 0...13) { totalheal += getstatusself(~regen~+i);  removestatusself(~regen~+i|ALL); if(getstatusself(~regen~+(i+1)) > 0){ inflictself(~regen~+i|getstatusself(~regen~+(i+1))); };}; if (totalheal > 0 && target.hp > 0) {  sfx(~_heal~); attackself(-totalheal); };  };,,,,
bleed0,Spooky_Bleed,curse,spoooooooooooooooooky! if you're reading this and aren't poking|around[;] stuff has gone wrong. Contact Jackeea!,YES,YES,NO,YES,YES,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totaldmg  = 0; for(i in 0...13) { totaldmg += getstatusself(~bleed~+i);  removestatusself(~bleed~+i|ALL); if(getstatusself(~bleed~+(i+1)) > 0){ inflictself(~bleed~+i|getstatusself(~bleed~+(i+1))); };}; if (totaldmg > 0) { pierceattackself(totaldmg); sfxdamage(self|totaldmg); };  };,,,,,,,,
bleed1,Bleed,bleed,Lose <value> health at the start of your turn. Lasts for 1 turn.|Stacking this increases the damage[;] not duration.,YES,NO,NO,NO,YES,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totaldmg  = 0; for(i in 0...13) { totaldmg += getstatusself(~bleed~+i);  removestatusself(~bleed~+i|ALL); if(getstatusself(~bleed~+(i+1)) > 0){ inflictself(~bleed~+i|getstatusself(~bleed~+(i+1))); };}; if (totaldmg > 0) { pierceattackself(totaldmg); sfxdamage(self|totaldmg); };  };,,,,,,,,
bleed2,Bleed,bleed,Lose <value> health at the start of your turn. Lasts for 2 turns.|Stacking this increases the damage[;] not duration.,YES,NO,NO,NO,YES,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totaldmg  = 0; for(i in 0...13) { totaldmg += getstatusself(~bleed~+i);  removestatusself(~bleed~+i|ALL); if(getstatusself(~bleed~+(i+1)) > 0){ inflictself(~bleed~+i|getstatusself(~bleed~+(i+1))); };}; if (totaldmg > 0) { pierceattackself(totaldmg); sfxdamage(self|totaldmg); };  };,,,,,,,,
bleed3,Bleed,bleed,Lose <value> health at the start of your turn. Lasts for 3 turns.|Stacking this increases the damage[;] not duration.,YES,NO,NO,NO,YES,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totaldmg  = 0; for(i in 0...13) { totaldmg += getstatusself(~bleed~+i);  removestatusself(~bleed~+i|ALL); if(getstatusself(~bleed~+(i+1)) > 0){ inflictself(~bleed~+i|getstatusself(~bleed~+(i+1))); };}; if (totaldmg > 0) { pierceattackself(totaldmg); sfxdamage(self|totaldmg); };  };,,,,,,,,
bleed4,Bleed,bleed,Lose <value> health at the start of your turn. Lasts for 4 turns.|Stacking this increases the damage[;] not duration.,YES,NO,NO,NO,YES,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totaldmg  = 0; for(i in 0...13) { totaldmg += getstatusself(~bleed~+i);  removestatusself(~bleed~+i|ALL); if(getstatusself(~bleed~+(i+1)) > 0){ inflictself(~bleed~+i|getstatusself(~bleed~+(i+1))); };}; if (totaldmg > 0) { pierceattackself(totaldmg); sfxdamage(self|totaldmg); };  };,,,,,,,,
bleed5,Bleed,bleed,Lose <value> health at the start of your turn. Lasts for 5 turns.|Stacking this increases the damage[;] not duration.,YES,NO,NO,NO,YES,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totaldmg  = 0; for(i in 0...13) { totaldmg += getstatusself(~bleed~+i);  removestatusself(~bleed~+i|ALL); if(getstatusself(~bleed~+(i+1)) > 0){ inflictself(~bleed~+i|getstatusself(~bleed~+(i+1))); };}; if (totaldmg > 0) { pierceattackself(totaldmg); sfxdamage(self|totaldmg); };  };,,,,,,,,
bleed6,Bleed,bleed,Lose <value> health at the start of your turn. Lasts for 6 turns.|Stacking this increases the damage[;] not duration.,YES,NO,NO,NO,YES,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totaldmg  = 0; for(i in 0...13) { totaldmg += getstatusself(~bleed~+i);  removestatusself(~bleed~+i|ALL); if(getstatusself(~bleed~+(i+1)) > 0){ inflictself(~bleed~+i|getstatusself(~bleed~+(i+1))); };}; if (totaldmg > 0) { pierceattackself(totaldmg); sfxdamage(self|totaldmg); };  };,,,,,,,,
bleed7,Bleed,bleed,Lose <value> health at the start of your turn. Lasts for 7 turns.|Stacking this increases the damage[;] not duration.,YES,NO,NO,NO,YES,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totaldmg  = 0; for(i in 0...13) { totaldmg += getstatusself(~bleed~+i);  removestatusself(~bleed~+i|ALL); if(getstatusself(~bleed~+(i+1)) > 0){ inflictself(~bleed~+i|getstatusself(~bleed~+(i+1))); };}; if (totaldmg > 0) { pierceattackself(totaldmg); sfxdamage(self|totaldmg); };  };,,,,,,,,
bleed8,Bleed,bleed,Lose <value> health at the start of your turn. Lasts for 8 turns.|Stacking this increases the damage[;] not duration.,YES,NO,NO,NO,YES,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totaldmg  = 0; for(i in 0...13) { totaldmg += getstatusself(~bleed~+i);  removestatusself(~bleed~+i|ALL); if(getstatusself(~bleed~+(i+1)) > 0){ inflictself(~bleed~+i|getstatusself(~bleed~+(i+1))); };}; if (totaldmg > 0) { pierceattackself(totaldmg); sfxdamage(self|totaldmg); };  };,,,,,,,,
bleed9,Bleed,bleed,Lose <value> health at the start of your turn. Lasts for 9 turns.|Stacking this increases the damage[;] not duration.,YES,NO,NO,NO,YES,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totaldmg  = 0; for(i in 0...13) { totaldmg += getstatusself(~bleed~+i);  removestatusself(~bleed~+i|ALL); if(getstatusself(~bleed~+(i+1)) > 0){ inflictself(~bleed~+i|getstatusself(~bleed~+(i+1))); };}; if (totaldmg > 0) { pierceattackself(totaldmg); sfxdamage(self|totaldmg); };  };,,,,,,,,
bleed10,Bleed,bleed,Lose <value> health at the start of your turn. Lasts for 10 turns.|Stacking this increases the damage[;] not duration.,YES,NO,NO,NO,YES,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totaldmg  = 0; for(i in 0...13) { totaldmg += getstatusself(~bleed~+i);  removestatusself(~bleed~+i|ALL); if(getstatusself(~bleed~+(i+1)) > 0){ inflictself(~bleed~+i|getstatusself(~bleed~+(i+1))); };}; if (totaldmg > 0) { pierceattackself(totaldmg); sfxdamage(self|totaldmg); };  };,,,,,,,,
bleed11,Bleed,bleed,Lose <value> health at the start of your turn. Lasts for 11 turns.|Stacking this increases the damage[;] not duration.,YES,NO,NO,NO,YES,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totaldmg  = 0; for(i in 0...13) { totaldmg += getstatusself(~bleed~+i);  removestatusself(~bleed~+i|ALL); if(getstatusself(~bleed~+(i+1)) > 0){ inflictself(~bleed~+i|getstatusself(~bleed~+(i+1))); };}; if (totaldmg > 0) { pierceattackself(totaldmg); sfxdamage(self|totaldmg); };  };,,,,,,,,
bleed12,Bleed,bleed,Lose <value> health at the start of your turn. Lasts for 12 turns.|Stacking this increases the damage[;] not duration. (Maximum duration!),YES,NO,NO,NO,YES,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totaldmg  = 0; for(i in 0...13) { totaldmg += getstatusself(~bleed~+i);  removestatusself(~bleed~+i|ALL); if(getstatusself(~bleed~+(i+1)) > 0){ inflictself(~bleed~+i|getstatusself(~bleed~+(i+1))); };}; if (totaldmg > 0) { pierceattackself(totaldmg); sfxdamage(self|totaldmg); };  };,,,,,,,,
pursuit,Pursuit,sword,Increases damage dealt by Pursuit by 3 this turn.,NO,NO,YES,NO,NO,,,,,,,,,,,
pursuitnext,Pursuing,sword,Pursuit deals 3 more damage next turn.,NO,NO,YES,NO,NO,,,,,,,,,,,
bound1,Bound,lock,Sets your first dice to have a value of 1.,YES,YES,NO,NO,YES,,,self.setvar(~bounddice~|0);,var counter = status.value; var skipvals = []; for(x in [1|2|3|4|5|6]){if(getstatusself(~bound~+x) > 0){skipvals.push(x);};}; var bounddice = self.getvar(~bounddice~); if(bounddice == 0){sfx(~_lock~);}; for(mydice in self.dicepool){if(mydice.available() && skipvals.indexOf(mydice.basevalue) == -1){if(bounddice > 0){bounddice-=1;}else if(counter > 0){counter-=1; mydice.basevalue = 1; mydice.animate(~flashshake~); self.setvar(~bounddice~|self.getvar(~bounddice~)+1);}}};,,,,,,,
bound2,Bound,lock,Sets your first dice to have a value of 2.,YES,YES,NO,NO,YES,,,self.setvar(~bounddice~|0);,var counter = status.value; var bounddice = self.getvar(~bounddice~); if(bounddice == 0){sfx(~_lock~);}; for(mydice in self.dicepool){if(mydice.available()){if(bounddice > 0){bounddice-=1;}else if(counter > 0){counter-=1; mydice.basevalue = 2; mydice.animate(~flashshake~); self.setvar(~bounddice~|self.getvar(~bounddice~)+1);}}};,,,,,,,
bound3,Bound,lock,Sets your first dice to have a value of 3.,YES,YES,NO,NO,YES,,,self.setvar(~bounddice~|0);,var counter = status.value; var bounddice = self.getvar(~bounddice~); if(bounddice == 0){sfx(~_lock~);}; for(mydice in self.dicepool){if(mydice.available()){if(bounddice > 0){bounddice-=1;}else if(counter > 0){counter-=1; mydice.basevalue = 3; mydice.animate(~flashshake~); self.setvar(~bounddice~|self.getvar(~bounddice~)+1);}}};,,,,,,,
bound4,Bound,lock,Sets your first dice to have a value of 4.,YES,YES,NO,NO,YES,,,self.setvar(~bounddice~|0);,var counter = status.value; var bounddice = self.getvar(~bounddice~); if(bounddice == 0){sfx(~_lock~);}; for(mydice in self.dicepool){if(mydice.available()){if(bounddice > 0){bounddice-=1;}else if(counter > 0){counter-=1; mydice.basevalue = 4; mydice.animate(~flashshake~); self.setvar(~bounddice~|self.getvar(~bounddice~)+1);}}};,,,,,,,
bound5,Bound,lock,Sets your first dice to have a value of 5.,YES,YES,NO,NO,YES,,,self.setvar(~bounddice~|0);,var counter = status.value; var bounddice = self.getvar(~bounddice~); if(bounddice == 0){sfx(~_lock~);}; for(mydice in self.dicepool){if(mydice.available()){if(bounddice > 0){bounddice-=1;}else if(counter > 0){counter-=1; mydice.basevalue = 5; mydice.animate(~flashshake~); self.setvar(~bounddice~|self.getvar(~bounddice~)+1);}}};,,,,,,,
bound6,Bound,lock,Sets your first dice to have a value of 6.,YES,YES,NO,NO,YES,,,self.setvar(~bounddice~|0);,var counter = status.value; var bounddice = self.getvar(~bounddice~); if(bounddice == 0){sfx(~_lock~);}; for(mydice in self.dicepool){if(mydice.available()){if(bounddice > 0){bounddice-=1;}else if(counter > 0){counter-=1; mydice.basevalue = 6; mydice.animate(~flashshake~); self.setvar(~bounddice~|self.getvar(~bounddice~)+1);}}};,,,,,,,
petrified1,Petrified,petrified,A random item can only be activated with a 1 next turn.,YES,YES,NO,NO,YES,var petrifieditems = self.getvar(~petrifieditems~); var petrifieditemslots = self.getvar(~petrifieditemslots~); trace(petrifieditems); if(petrifieditems == 0 # petrifieditems.length == 0){petrifieditems = []; petrifieditemslots = [];}; self.setvar(~petrifieditems~|petrifieditems); self.setvar(~petrifieditemslots~|petrifieditemslots);,,,var freeslots = [~FREE1~[;]~FREE2~[;]~FREE3~[;]~FREE4~[;]~FREE5~[;]~FREE6~]; var poss = []; var lowpriority = []; var petrifieditems = self.getvar(~petrifieditems~); var petrifieditemslots = self.getvar(~petrifieditemslots~); for(eq in self.equipment){ if(eq.needsdoubles){poss.push(eq);}else if(eq.countdown == 0){ if(eq.getslots()[0].indexOf(~REQUIRE~) > -1){ lowpriority.push(eq); }else{ poss.push(eq); }; }; }; var count = 0; poss = shuffle(poss); if(poss.length == 0){poss = lowpriority; poss = shuffle(poss);}; while(poss.length > 0 && count < status.value){count+=1; if(poss.length == 0){ poss = lowpriority; poss=shuffle(poss); }; var r = poss.pop(); petrifieditems.push(r); petrifieditemslots.push(r.getslots()); var modifier = []; var newslots = []; if(r.getslots()[0] == ~DOUBLES~){newslots = [~REQUIRE1~|~REQUIRE1~];}else{for(s in r.getslots()){ if(freeslots.indexOf(s) > -1){ modifier.push(s); }else{newslots.push(~REQUIRE1~);}; };}; r.changeslots(newslots.concat(modifier)); r.animate(~flashandshake~);}; self.setvar(~petrifieditems~[;]petrifieditems); self.setvar(~petrifieditemslots~[;]petrifieditemslots); sfx(~_weaken~); sfx(~_lock~[;]~~[;]0.3);,,,,,,,var items = self.getvar(~petrifieditems~); trace(items); var slots = self.getvar(~petrifieditemslots~); var x = 0; while(x < items.length){ items[x].changeslots(slots[x]); x = x+1; }; self.setvar(~petrifieditems~[;][]); self.setvar(~petrifieditemslots~[;][]);
petrified2,Petrified,petrified,A random item can only be activated with a 2 next turn.,YES,YES,NO,NO,YES,var petrifieditems = self.getvar(~petrifieditems~); var petrifieditemslots = self.getvar(~petrifieditemslots~); trace(petrifieditems); if(petrifieditems == 0 # petrifieditems.length == 0){petrifieditems = []; petrifieditemslots = [];}; self.setvar(~petrifieditems~|petrifieditems); self.setvar(~petrifieditemslots~|petrifieditemslots);,,,var freeslots = [~FREE1~[;]~FREE2~[;]~FREE3~[;]~FREE4~[;]~FREE5~[;]~FREE6~]; var poss = []; var lowpriority = []; var petrifieditems = self.getvar(~petrifieditems~); var petrifieditemslots = self.getvar(~petrifieditemslots~); for(eq in self.equipment){ if(eq.needsdoubles){poss.push(eq);}else if(eq.countdown == 0){ if(eq.getslots()[0].indexOf(~REQUIRE~) > -1){ lowpriority.push(eq); }else{ poss.push(eq); }; }; }; var count = 0; poss = shuffle(poss); if(poss.length == 0){poss = lowpriority; poss = shuffle(poss);}; while(poss.length > 0 && count < status.value){count+=1; if(poss.length == 0){ poss = lowpriority; poss=shuffle(poss); }; var r = poss.pop(); petrifieditems.push(r); petrifieditemslots.push(r.getslots()); var modifier = []; var newslots = []; if(r.getslots()[0] == ~DOUBLES~){newslots = [~REQUIRE2~|~REQUIRE2~];}else{for(s in r.getslots()){ if(freeslots.indexOf(s) > -1){ modifier.push(s); }else{newslots.push(~REQUIRE2~);}; };}; r.changeslots(newslots.concat(modifier)); sfx(~_weaken~); sfx(~_lock~[;]~~[;]0.3); r.animate(~flashandshake~);}; self.setvar(~petrifieditems~[;]petrifieditems); self.setvar(~petrifieditemslots~[;]petrifieditemslots);,,,,,,,var items = self.getvar(~petrifieditems~); var slots = self.getvar(~petrifieditemslots~); var x = 0; while(x < items.length){ items[x].changeslots(slots[x]); x = x+1; }; self.setvar(~petrifieditems~[;][]); self.setvar(~petrifieditemslots~[;][]);
petrified3,Petrified,petrified,A random item can only be activated with a 3 next turn.,YES,YES,NO,NO,YES,var petrifieditems = self.getvar(~petrifieditems~); var petrifieditemslots = self.getvar(~petrifieditemslots~); trace(petrifieditems); if(petrifieditems == 0 # petrifieditems.length == 0){petrifieditems = []; petrifieditemslots = [];}; self.setvar(~petrifieditems~|petrifieditems); self.setvar(~petrifieditemslots~|petrifieditemslots);,,,var freeslots = [~FREE1~[;]~FREE2~[;]~FREE3~[;]~FREE4~[;]~FREE5~[;]~FREE6~]; var poss = []; var lowpriority = []; var petrifieditems = self.getvar(~petrifieditems~); var petrifieditemslots = self.getvar(~petrifieditemslots~); for(eq in self.equipment){ if(eq.needsdoubles){poss.push(eq);}else if(eq.countdown == 0){ if(eq.getslots()[0].indexOf(~REQUIRE~) > -1){ lowpriority.push(eq); }else{ poss.push(eq); }; }; }; var count = 0; poss = shuffle(poss); if(poss.length == 0){poss = lowpriority; poss = shuffle(poss);}; while(poss.length > 0 && count < status.value){count+=1; if(poss.length == 0){ poss = lowpriority; poss=shuffle(poss); }; var r = poss.pop(); petrifieditems.push(r); petrifieditemslots.push(r.getslots()); var modifier = []; var newslots = []; if(r.getslots()[0] == ~DOUBLES~){newslots = [~REQUIRE3~|~REQUIRE3~];}else{for(s in r.getslots()){ if(freeslots.indexOf(s) > -1){ modifier.push(s); }else{newslots.push(~REQUIRE3~);}; };}; r.changeslots(newslots.concat(modifier)); sfx(~_weaken~); sfx(~_lock~[;]~~[;]0.3); r.animate(~flashandshake~);}; self.setvar(~petrifieditems~[;]petrifieditems); self.setvar(~petrifieditemslots~[;]petrifieditemslots);,,,,,,,var items = self.getvar(~petrifieditems~); var slots = self.getvar(~petrifieditemslots~); var x = 0; while(x < items.length){ items[x].changeslots(slots[x]); x = x+1; }; self.setvar(~petrifieditems~[;][]); self.setvar(~petrifieditemslots~[;][]);
petrified4,Petrified,petrified,A random item can only be activated with a 4 next turn.,YES,YES,NO,NO,YES,var petrifieditems = self.getvar(~petrifieditems~); var petrifieditemslots = self.getvar(~petrifieditemslots~); trace(petrifieditems); if(petrifieditems == 0 # petrifieditems.length == 0){petrifieditems = []; petrifieditemslots = [];}; self.setvar(~petrifieditems~|petrifieditems); self.setvar(~petrifieditemslots~|petrifieditemslots);,,,var freeslots = [~FREE1~[;]~FREE2~[;]~FREE3~[;]~FREE4~[;]~FREE5~[;]~FREE6~]; var poss = []; var lowpriority = []; var petrifieditems = self.getvar(~petrifieditems~); var petrifieditemslots = self.getvar(~petrifieditemslots~); for(eq in self.equipment){ if(eq.needsdoubles){poss.push(eq);}else if(eq.countdown == 0){ if(eq.getslots()[0].indexOf(~REQUIRE~) > -1){ lowpriority.push(eq); }else{ poss.push(eq); }; }; }; var count = 0; poss = shuffle(poss); if(poss.length == 0){poss = lowpriority; poss = shuffle(poss);}; while(poss.length > 0 && count < status.value){count+=1; if(poss.length == 0){ poss = lowpriority; poss=shuffle(poss); }; var r = poss.pop(); petrifieditems.push(r); petrifieditemslots.push(r.getslots()); var modifier = []; var newslots = []; if(r.getslots()[0] == ~DOUBLES~){newslots = [~REQUIRE4~|~REQUIRE4~];}else{for(s in r.getslots()){ if(freeslots.indexOf(s) > -1){ modifier.push(s); }else{newslots.push(~REQUIRE4~);}; };}; r.changeslots(newslots.concat(modifier)); sfx(~_weaken~); sfx(~_lock~[;]~~[;]0.3); r.animate(~flashandshake~);}; self.setvar(~petrifieditems~[;]petrifieditems); self.setvar(~petrifieditemslots~[;]petrifieditemslots);,,,,,,,var items = self.getvar(~petrifieditems~); var slots = self.getvar(~petrifieditemslots~); var x = 0; while(x < items.length){ items[x].changeslots(slots[x]); x = x+1; }; self.setvar(~petrifieditems~[;][]); self.setvar(~petrifieditemslots~[;][]);
petrified5,Petrified,petrified,A random item can only be activated with a 5 next turn.,YES,YES,NO,NO,YES,var petrifieditems = self.getvar(~petrifieditems~); var petrifieditemslots = self.getvar(~petrifieditemslots~); trace(petrifieditems); if(petrifieditems == 0 # petrifieditems.length == 0){petrifieditems = []; petrifieditemslots = [];}; self.setvar(~petrifieditems~|petrifieditems); self.setvar(~petrifieditemslots~|petrifieditemslots);,,,var freeslots = [~FREE1~[;]~FREE2~[;]~FREE3~[;]~FREE4~[;]~FREE5~[;]~FREE6~]; var poss = []; var lowpriority = []; var petrifieditems = self.getvar(~petrifieditems~); var petrifieditemslots = self.getvar(~petrifieditemslots~); for(eq in self.equipment){ if(eq.needsdoubles){poss.push(eq);}else if(eq.countdown == 0){ if(eq.getslots()[0].indexOf(~REQUIRE~) > -1){ lowpriority.push(eq); }else{ poss.push(eq); }; }; }; var count = 0; poss = shuffle(poss); if(poss.length == 0){poss = lowpriority; poss = shuffle(poss);}; while(poss.length > 0 && count < status.value){count+=1; if(poss.length == 0){ poss = lowpriority; poss=shuffle(poss); }; var r = poss.pop(); petrifieditems.push(r); petrifieditemslots.push(r.getslots()); var modifier = []; var newslots = []; if(r.getslots()[0] == ~DOUBLES~){newslots = [~REQUIRE5~|~REQUIRE5~];}else{for(s in r.getslots()){ if(freeslots.indexOf(s) > -1){ modifier.push(s); }else{newslots.push(~REQUIRE5~);}; };}; r.changeslots(newslots.concat(modifier)); sfx(~_weaken~); sfx(~_lock~[;]~~[;]0.3); r.animate(~flashandshake~);}; self.setvar(~petrifieditems~[;]petrifieditems); self.setvar(~petrifieditemslots~[;]petrifieditemslots);,,,,,,,var items = self.getvar(~petrifieditems~); var slots = self.getvar(~petrifieditemslots~); var x = 0; while(x < items.length){ items[x].changeslots(slots[x]); x = x+1; }; self.setvar(~petrifieditems~[;][]); self.setvar(~petrifieditemslots~[;][]);
petrified6,Petrified,petrified,A random item can only be activated with a 6 next turn.,YES,YES,NO,NO,YES,var petrifieditems = self.getvar(~petrifieditems~); var petrifieditemslots = self.getvar(~petrifieditemslots~); trace(petrifieditems); if(petrifieditems == 0 # petrifieditems.length == 0){petrifieditems = []; petrifieditemslots = [];}; self.setvar(~petrifieditems~|petrifieditems); self.setvar(~petrifieditemslots~|petrifieditemslots);,,,var freeslots = [~FREE1~[;]~FREE2~[;]~FREE3~[;]~FREE4~[;]~FREE5~[;]~FREE6~]; var poss = []; var lowpriority = []; var petrifieditems = self.getvar(~petrifieditems~); var petrifieditemslots = self.getvar(~petrifieditemslots~); for(eq in self.equipment){ if(eq.needsdoubles){poss.push(eq);}else if(eq.countdown == 0){ if(eq.getslots()[0].indexOf(~REQUIRE~) > -1){ lowpriority.push(eq); }else{ poss.push(eq); }; }; }; var count = 0; poss = shuffle(poss); if(poss.length == 0){poss = lowpriority; poss = shuffle(poss);}; while(poss.length > 0 && count < status.value){count+=1; if(poss.length == 0){ poss = lowpriority; poss=shuffle(poss); }; var r = poss.pop(); petrifieditems.push(r); petrifieditemslots.push(r.getslots()); var modifier = []; var newslots = []; if(r.getslots()[0] == ~DOUBLES~){newslots = [~REQUIRE6~|~REQUIRE6~];}else{for(s in r.getslots()){ if(freeslots.indexOf(s) > -1){ modifier.push(s); }else{newslots.push(~REQUIRE6~);}; };}; r.changeslots(newslots.concat(modifier)); sfx(~_weaken~); sfx(~_lock~[;]~~[;]0.3); r.animate(~flashandshake~);}; self.setvar(~petrifieditems~[;]petrifieditems); self.setvar(~petrifieditemslots~[;]petrifieditemslots);,,,,,,,var items = self.getvar(~petrifieditems~); var slots = self.getvar(~petrifieditemslots~); var x = 0; while(x < items.length){ items[x].changeslots(slots[x]); x = x+1; }; self.setvar(~petrifieditems~[;][]); self.setvar(~petrifieditemslots~[;][]);
cache,Cached,dice,Store <value> dice for next turn.,YES,NO,YES,NO,NO,,,,,,,,,,,
lightstatus,Enlightened,dice,Get [yellow]<value>[] extra dice next turn.,YES,NO,YES,NO,NO,var total = 0; for(x in 1...7){ total = total+ getstatusself(~stash~+x); }; self.setvar(~stashcount~[;]total); self.setvar(~doublestashcount~[;]total*2); self.setvar(~triplestashcount~[;]total*3); self.setvar(~quadruplestashcount~[;]total*4);,,,,,,,,,,
lamppost1,Lamppost,dice,Get a free [yellow]1[] next turn.,NO,NO,YES,NO,NO,,,,,,,,,,,
lamppost2,Lamppost,dice,Get a free [yellow]2[] next turn.,NO,NO,YES,NO,NO,,,,,,,,,,,
lamppost3,Lamppost,dice,Get a free [yellow]3[] next turn.,NO,NO,YES,NO,NO,,,,,,,,,,,
lamppost4,Lamppost,dice,Get a free [yellow]4[] next turn.,NO,NO,YES,NO,NO,,,,,,,,,,,
lamppost5,Lamppost,dice,Get a free [yellow]5[] next turn.,NO,NO,YES,NO,NO,,,,,,,,,,,
lamppost6,Lamppost,dice,Get a free [yellow]6[] next turn.,NO,NO,YES,NO,NO,,,,,,,,,,,
tickly,Tickled,dice,Get <value> free [yellow]1[]s next turn.,YES,NO,YES,NO,NO,,,,,,,,,,,
lifesteal,Lifesteal,lifesteal,Your attacks deal [sword]<value> less damage[;] but|heal you for [heal]<value> health.,YES,YES,NO,NO,NO,,,,,,,,,var amt = getstatusself(~lifesteal~); if(dmg < amt){attackself(-dmg); target.hp+=dmg;}else{attackself(-amt); target.hp+=amt; }; sfx(~_heal~);,,
mechanical_lantern,Mechanicalantern,dice,Get <value> free dice next turn.,YES,NO,YES,NO,NO,,,,,,,,,,,
ratchet,Ratchet,cog,Increases the range on MAX or MIN|equipment by <value> this turn.,YES,YES,NO,NO,NO,,,,,,,,,,,
dynamo,Beam_Power,dynamo,Beam weapons[;] such as [red]Focus Beam[][;] [yellow]Solar Beam[][;]|[blue]Lunar Beam[] and [orange]Terra Beam[][;] all deal [dynamo]<value> damage.,YES,NO,NO,NO,NO,self.setvar(~dynamo~|status.value);,,,,,,,self.setvar(~dynamo~|0);,,,self.setvar(~dynamo~|status.value);
batted,Battered,dice,Enemy caught the dice you batted!|They get <value> more dice next turn.,YES,YES,NO,NO,NO,,,,,,,,,,,
helium,Inflated,helium,Your dice are... floaty!|More helium means faster floatiness.,YES,YES,NO,NO,YES,if(self.isplayer && !self.varexists(~dicegrav_trigger~)){var s = new elements.Skill(~Helium Script~); var tw = new motion.actuators.SimpleActuator(null|0.05|null);  tw._repeat = -1; tw.onRepeat(s.execute|[self|target]);  self.setvar(~dicegrav_trigger~|tw); tw.move(); s.remove(); };,,,,,,,,,,if(self.varexists(~dicegrav_trigger~)){self.getvar(~dicegrav_trigger~).stop(); self.resetvar(~dicegrav_trigger~);};
whelm,Whelmed,sword,Whelm deals <value> more damage.,YES,NO,NO,NO,NO,,,,,,,,,,,
polymorph,Polymorph,polymorph,A random item is permanently replaced|with another random item.,YES,YES,NO,NO,YES,,,,var poss = []; var lowp = []; for(eq in self.equipment){if(!eq.hastag(~skillcard~) && !eq.hastag(~powercard~)){if(eq.weakened # eq.shockedsetting != 0){lowp.push(eq);}else{poss.push(eq);};};}; lowp = shuffle(lowp); poss = shuffle(poss); if(poss.length <= 0){poss = lowp;}; var count = 0; while(count < status.value && count < poss.length){var replaceequip = poss[count]; count+=1; var newequip; if(replaceequip.size == 1){newequip = rand(getequipmentlist(null|[~small~]|[~excludefromrandomlists~|~skillcard~|~robotonly~|~witchonly~|~powercard~|~alternateversion~|~onceperbattle~]));}else{newequip = rand(getequipmentlist(null|[~large~]|[~excludefromrandomlists~|~skillcard~|~robotonly~|~witchonly~|~powercard~|~alternateversion~|~onceperbattle~]));}; var  x = replaceequip.x; var y = replaceequip.y; if(replaceequip.upgraded){replaceequip.create(newequip+~+~|true|false|true);}else if(replaceequip.weakened){if(replaceequip.originallyupgraded){replaceequip.create(newequip+~+~|true|true);}else{replaceequip.create(newequip);}; replaceequip.downgrade();}else{replaceequip.create(newequip);}; replaceequip.x = x; replaceequip.y = y; replaceequip.animate(~flashandshake~); replaceequip.changeslots(replaceequip.getslots());  }; sfx(~jester_discard~);,,,,,,,
polymorphall,Polymorph_All,polymorph,ALL items get permanently replaced with random items.,NO,YES,NO,NO,YES,,,,var poss = []; for(eq in self.equipment){if(!eq.hastag(~skillcard~) && !eq.hastag(~powercard~)){poss.push(eq);};}; poss = shuffle(poss); var count = 0; while(count < poss.length){var replaceequip = poss[count]; count+=1; var newequip; if(replaceequip.size == 1){newequip = rand(getequipmentlist(null|[~small~]|[~excludefromrandomlists~|~skillcard~|~robotonly~|~witchonly~|~powercard~|~alternateversion~|~onceperbattle~]));}else{newequip = rand(getequipmentlist(null|[~large~]|[~excludefromrandomlists~|~skillcard~|~robotonly~|~witchonly~|~powercard~|~alternateversion~|~onceperbattle~]));}; var  x = replaceequip.x; var y = replaceequip.y; if(replaceequip.upgraded){replaceequip.create(newequip+~+~|true|false|true);}else if(replaceequip.weakened){if(replaceequip.originallyupgraded){replaceequip.create(newequip+~+~|true|true);}else{replaceequip.create(newequip);}; replaceequip.downgrade();}else{replaceequip.create(newequip);}; replaceequip.x = x; replaceequip.y = y; replaceequip.animate(~flashandshake~); replaceequip.changeslots(replaceequip.getslots());  }; sfx(~jester_discard~);,,,,,,,
nerfed,Nerfed,nerfed,At the start of your turn[;] make a random item|harder to play[;] <value> time(s).,YES,NO,NO,NO,YES,,,,var requireslots = [~REQUIRE1~[;] ~REQUIRE2~[;] ~REQUIRE3~[;] ~REQUIRE4~[;] ~REQUIRE5~[;] ~REQUIRE6~]; var maxslots = [~MAX5~[;] ~MAX4~[;] ~MAX3~[;] ~MAX2~]; var minslots = [~MIN2~[;] ~MIN3~[;] ~MIN4~[;] ~MIN5~]; var freeslots = [~FREE1~[;] ~FREE2~[;] ~FREE3~[;] ~FREE4~[;] ~FREE5~[;] ~FREE6~]; for (x in 0...status.value) { var poss = []; for (eq in self.equipment) { if (eq.ready && eq.availablethisturn) { poss.push(eq); } }; var output = []; if (poss.length > 0) { var eq = rand(poss); if (eq.skillcard == ~~ && eq.countdown == 0) { if (eq.needsdoubles) { var r = rand([1[;] 2[;] 3[;] 4[;] 5[;] 6]); output = [~REQUIRE~+r[;] ~REQUIRE~+r]; eq.needsdoubles = false; } else { for (s in eq.getslots()) {  if (freeslots.indexOf(s) != -1) { output.push(s); } else if (maxslots.indexOf(s) != -1) { if (maxslots.indexOf(s) + 1 == maxslots.length) { output.push(~REQUIRE1~); } else { output.push(maxslots[maxslots.indexOf(s) + 1]); }; } else if (minslots.indexOf(s) != -1) { if (minslots.indexOf(s) + 1 == minslots.length) { output.push(~REQUIRE6~); } else { output.push(minslots[minslots.indexOf(s) + 1]); }; } else if (s == ~EVEN~) { output.push(~REQUIRE~+rand([2[;] 4[;] 6])); } else if (s == ~ODD~) { output.push(~REQUIRE~+rand([1[;] 3[;] 5])); } else if (s == ~NORMAL~) { output.push(~MAX5~); } else if (requireslots.indexOf(s) != -1) { output.push(s); output.push(s); } else { output.push(s); }; }; }; if (output.length > 0) { eq.animate(~flashandshake~); if(eq.size == 1 && output.length > 3){ eq.changeslots([output[0][;] output[1][;] output[2]]); }else if (output.length <= 4) { eq.changeslots(output); } else { eq.changeslots([output[0][;] output[1][;] output[2][;] output[3]]); }; }; } else if (eq.skillcard == ~~ && eq.countdown != 0) { eq.animate(~flashandshake~); eq.countdown = eq.countdown * 1.1 + 2; eq.remainingcountdown = eq.remainingcountdown * 1.1 + 2; }; }; }; sfx(~_weaken~);,,,,,,,
reaper,Reaper,reaper,Your next attack heals you for the damage done.,YES,NO,NO,NO,NO,self.resetvar(~reapertempcounter~);,,,,,,,,if(self.getvar(~reapertempcounter~) < status.value){attackself(-dmg); sfx(~_heal~);}; self.setvar(~reapertempcounter~|self.getvar(~reapertempcounter~)+1); var tw = new motion.actuators.SimpleActuator(null|0.01); tw._repeat = 1; s.script=~removestatusself(status.name|1); self.resetvar(\~reapertempcounter\~);~; tw.onComplete(s); tw.move();,,
essence_base,Base_Essence,baseessence,Does nothing. When invoked:|Take [sword]4 damage for each Base Essence.,YES,NO,NO,NO,NO,,,,,,,,,,,
essence_fire,Flame_Essence,fireessence,Does nothing. When invoked:|Receive [fire]1 burn for each Flame Essence.,YES,NO,NO,NO,NO,,,,,,,,,,,
essence_ice,Frost_Essence,iceessence,Does nothing. When invoked:|Receive [ice]1 freeze for each Frost Essence.,YES,NO,NO,NO,NO,,,,,,,,,,,
essence_shock,Air_Essence,airessence,Does nothing. When invoked:|Receive [shock]1 shock for each Air Essence.,YES,NO,NO,NO,NO,,,,,,,,,,,
essence_weaken,Earth_Essence,earthessence,Does nothing. When invoked:|Receive [weaken]1 weaken for each Earth Essence.,YES,NO,NO,NO,NO,,,,,,,,,,,
essence_poison,Toxic_Essence,poisonessence,Does nothing. When invoked:|Receive [poison]2 poison for each Toxic Essence.,YES,NO,NO,NO,NO,,,,,,,,,,,
essence_dark,Dark_Essence,curseessence,Does nothing. When invoked:|Receive a bad status ([curse]Curse[;] [lock]Lock[;] [shock]Stun),YES,NO,NO,NO,NO,,,,,,,,,,,
mf_stun,Stun,stun,Random equipment is disabled for the turn.,YES,YES,NO,NO,YES,,,,var goodeq = []; var lowpriority = []; for(eq in self.equipment){ if(eq.availablethisturn && eq.skillcard == ~~){ if(eq.weakened # eq.shockedsetting != 0){lowpriority.push(eq);}else{goodeq.push(eq);}; }; }; lowpriority = shuffle(lowpriority); goodeq = shuffle(goodeq); if(goodeq.length <= 0){goodeq = lowpriority;}; var s = getstatusself(~mf_stun~); while(goodeq.length > 0 && s > 0){ s-=1; var r = goodeq.pop(); r.availablethisturn = false;  r.unavailabledetails = [~Stunned~]; r.animate(~flashandshake~); }; sfx(~_shock~);,,,,,,,
alternate_mf_stun,Stun?,stun,Lose a dice next turn.,YES,YES,NO,NO,YES,self.bonusdice-=1;,,,//var count = 0; for(mydice in self.dicepool){if(mydice.available()){if(count < status.value){count+=1; mydice.animate(~disappear~);};};}; sfx(~_shock~);,,,,,,,
nothing,Nothing,nothing,Does absolutely nothing.,NO,YES,NO,NO,NO,,,,,,,,,,,
alternate_nothing,Nothing?,nothing,Does absolutely nothing[;] but with a question mark.,NO,YES,NO,NO,NO,,,,,,,,,,,
grace,Grace,grace,At the start of your turn[;] if your health is less than|your Grace ([grace]<value>[])[;] swap your health and your Grace.,YES,NO,NO,NO,NO,,,var grace = status.value; var diff = grace - self.hp; if(diff > 0){ pierceattackself(-diff); sfx(~_heal~); sfx(~_survive~); removestatusself(~grace~[;]diff); status.set_displayvalue(status.value); };,,,,,,,,
healaftercombat,Heal_After_Combat,heal,After combat[;] recover [heal]<value> health.|Doesn't trigger if you flee.,YES,NO,NO,NO,NO,,,,,,,,if(!flee){attackself(-getstatusself(~healaftercombat~)); sfx(~_heal~);};,,,
poisonovertime,Toxins,poison,At the end of your turn[;] receive [poison]1 poison.|Lasts for <value> turns.,YES,NO,NO,NO,YES,,,,,,,removestatusself(status.name|1); inflictself(POISON); sfx(~_poison~);,,,,
revolver,Ammunition,sword,After this reaches 6[;] reduce this by 6|and deal [sword]18 damage.,YES,NO,NO,NO,NO,var tempvalue = status.value; while(tempvalue >= 6){ attack(18); sfxdamage(target|18); tempvalue -= 6; var tw = new motion.actuators.SimpleActuator(null|0.01|null); var s = new elements.Skill(~Against all odds_old~); s.script = ~  removestatusself(\~~ + status.type + ~\~|6);~; tw.onComplete(s.execute|[self|target]); tw.move(); };,,,,,,,,,,
shielddown,Shield_Down,potion,At the start of your turn[;] lose [shield]<value> shield.,YES,NO,NO,NO,YES,,,,removestatusself(SHIELD|status.value);,,,,,,,
mf_skipturn,Skip_Turn,skipturn,Skips your next turn.,YES,NO,NO,NO,YES,if(!self.isplayer){inflict(~mf_bonusturn~|inflicted_value-1); inflict(EXTRATURN);},,if(!self.isplayer){var ac = new motion.actuators.SimpleActuator(null|0.1); var s = new elements.Skill(~mf_blankskill~); s.script=~removestatusself(\~mf_skipturn\~|ALL);~; ac.onComplete(s.execute|[self|target]); ac.move();};,if(self.isplayer){var ac = new motion.actuators.SimpleActuator(null|0.1); var s = new elements.Skill(~mf_blankskill~); s.script=~self.endturnnow(); removestatusself(\~mf_skipturn\~|1);~; ac.onComplete(s.execute|[self|target]); ac.move();};,,,,,,,
mf_bonusturn,Time_Loop,skipturn,At the start of your next turn[;] gain an extra turn.,YES,NO,NO,YES,NO,,,,if(self.isplayer){inflictself(EXTRATURN);}else{inflict(~mf_skipturn~);}; var tw = new motion.actuators.SimpleActuator(null|0.01|null); var s = new elements.Skill(~Against all odds_old~); s.script = ~  removestatusself(\~~ + status.type + ~\~|1);~; tw.onComplete(s.execute|[self|target]); tw.move();,,,,,,,
mf_bonusturn_nextturn,Send_Help,skipturn,So many extra turn statuses. If you're thinking about|fiddling with extra turns[;] my advice: don't,YES,NO,NO,YES,NO,,,,inflictself(~mf_bonusturn~); var tw = new motion.actuators.SimpleActuator(null|0.01|null); var s = new elements.Skill(~Against all odds_old~); s.script = ~  removestatusself(\~~ + status.type + ~\~|1);~; tw.onComplete(s.execute|[self|target]); tw.move();,,,,,,,
mf_suffocate,Suffocate,lock,At the start of your turn[;] lock any blinded dice.,NO,YES,NO,NO,YES,,,inflictself(LOCK|getstatusself(BLIND));,,,,,,,,
alternate_mf_suffocate,Suffocate?,lock,At the start of your turn[;] receive [lock]1 lock|per turn of [blind] Blind you have.,NO,YES,NO,NO,YES,,,inflictself(LOCK|getstatusself(BLIND));,,,,,,,,
mf_healnextturn,Heal_Next_Turn,heart,At the start of next turn[;] recover [heart]<value> health.,YES,NO,YES,NO,NO,,,,,,,,,,,pierceattackself(-status.value); sfx(~_heal~);
mf_cursecarryover,Curse_Next_Turn,curse,At the start of next turn[;] convert this into [curse]<value> curse.,YES,NO,NO,NO,YES,,,,,,,,,,,
mf_magma,Magma,magma,At the start of your turn[;] take [fire]<value> damage.|Doesn't disappear after your turn.,YES,NO,NO,NO,YES,,,,attackself(status.value|FIRE); sfx(~_fire~);,,,,,,,
mf_shiver,Shiver,shiver,At the start of your turn[;] take [ice]<value> damage.|Doesn't disappear after your turn.,YES,NO,NO,NO,YES,,,,attackself(status.value|ICE); sfx(~_ice~);,,,,,,,
alternate_mf_magma,Magma?,magma,At the start of your turn[;] take [fire]2x<value> damage[;]|then reduce how much [magma]Magma? you have by half.,YES,NO,NO,NO,YES,,,,attackself(status.value*2|FIRE); var tw = new motion.actuators.SimpleActuator(null|0.01|null); var s = new elements.Skill(~Against all odds_old~); s.script = ~  removestatusself(\~~ + status.type + ~\~|(~ + status.value+ ~+1)/2);~; tw.onComplete(s.execute|[self|target]); tw.move(); sfx(~_fire~);,,,,,,,
alternate_mf_shiver,Shiver?,shiver,At the start of your turn[;] take [ice]2x<value> damage[;]|then reduce how much [shiver]Shiver? you have by half.,YES,NO,NO,NO,YES,,,,attackself(status.value*2|ICE); var tw = new motion.actuators.SimpleActuator(null|0.01|null); var s = new elements.Skill(~Against all odds_old~); s.script = ~  removestatusself(\~~ + status.type + ~\~|(~ + status.value+ ~+1)/2);~; tw.onComplete(s.execute|[self|target]); tw.move(); sfx(~_ice~);,,,,,,,
slowregen,Rejuvenation,heal,Restore [heal]1 health every 2 seconds[;] for <value> seconds.,YES,NO,NO,NO,NO,,,,,,,,,,,
nospellbook,No_Spellbook,nospellbook,Spellbook is disabled for the rest of this battle.|Rely on your remaining spells!,NO,NO,NO,NO,NO,if(self.getskillcard() != null){var s = self.getskillcard(); s.animate(~curse~); s.ready=false;}; ,,self.getskillcard().ready=false;,self.getskillcard().animate(~curse~);,,,,,,,
mf_poweredup,Powered_Up!,star,You[quote]ve used [star]<value> [yellow]Power Bolts[] this turn.,YES,YES,NO,NO,NO,,,,,,,,,,,
envenomate,Envenomate,poison,Your next attack that deals [sword]<value> or less damage|instead has its damage converted into poison.,YES,YES,NO,NO,NO,,,,,,,,,if(dmg <= getstatusself(~envenomate~)){inflict(POISON|dmg); sfx(~_poison~); target.hp+=dmg;}; removestatusself(status.type|ALL);,,
criticalhit,Critical_Hit,criticalhit,Your attacks have a <value>% chance to deal double damage.,YES,YES,NO,NO,NO,,,,,,,,,if(chance(status.value)){ target.hp = target.hp-dmg; sfx(~_fury~); self.textparticle(~Critical Hit!~); };,,
criticalhit_baseamount,Critical_Hit_Internal,curse,Whoops! Probably shouldn't be seeing this.,YES,YES,NO,YES,NO,if(getstatusself(~luck+~) > 0){inflictself(~criticalhit~|100);}else if(getstatusself(~luck~) > 0){inflictself(~criticalhit~|status.value * 2);}else{inflictself(~criticalhit~|status.value);};,if(inflicted_type == ~luck+~){inflictself(~criticalhit~|100); sfx(~_fury~);}; if(inflicted_type == ~luck~){inflictself(~criticalhit~|getstatusself(~criticalhit~)); sfx(~_fury~);}; if(getstatusself(~criticalhit~) > 100){removestatusself(~criticalhit~|ALL); inflictself(~criticalhit~|100);};,,,,,,,,,
mendingregen,Mending,heal,Your next <value> attacks grant up to 3 turns of [heal] Regen.|(Regen heals you for 1 health/turn),YES,YES,NO,NO,NO,,,,,,,,,if(dmg > 3){inflictself(~regen3~);}else if(dmg > 0){inflictself(~regen~+dmg);} sfx(~_cure~); removestatusself(status.type|1);,,
weakennextturn,Weaken_Next_Turn,weaken,Receive [weaken]<value> weaken for the enemy's turn.,YES,YES,NO,NO,NO,,,,,,,inflict(~dummyweaken~|status.value);,,,,
dummyweaken,Weaken_Enemy_Next_Turn,weaken,Whoops! Probably shouldn't be seeing this.,YES,YES,NO,NO,NO,,,inflict(WEAKEN|status.value);,,,,,,,,
mf_weakeneachturn,Weaken_Each_Turn,weaken,Receive [weaken]<value> weaken each turn.,YES,NO,NO,NO,NO,inflict(WEAKEN|status.value);,,,,,,inflict(~dummyweaken~|status.value);,,,,
shieldoflight,Shield_Of_Light,shieldoflight,Whenever you take damage this turn[;] heal [heal]<value> health per|turn[;] for turns equal to the damage (maximum: 5),YES,NO,YES,NO,NO,,,,,,,,,,if(dmg > 5){inflictself(~regen5~|status.value);}else if(dmg > 0){inflictself(~regen~+dmg|status.value);} sfx(~_cure~);,
mf_recurseion,Recurseion,curse,(should not appear),NO,NO,YES,YES,NO,,,,,,,,,,,
curseeachturn,Curse_Each_Turn,curse,Receive [curse]<value> curse each turn for the rest of battle.,YES,NO,NO,NO,YES,,,inflict(CURSE); sfx(~_curse~);,,,,,,,,
mf_maintaincurse,Maintain_Curse,sword,Maintain curse between turns.,NO,NO,NO,YES,NO,,,,,,,for(st in self.status){if(st.type == CURSE){st.remove_at_endturn = false;};};,,,,for(st in self.status){if(st.type == CURSE){st.remove_at_endturn = true;};};
tempbear_witch,Bear!,potion,You're a bear!,NO,NO,NO,NO,NO,,,,,,,,,,,
internal_timefreeze_lockout,Lockout,skipturn,Any dice that aren't a 1 immediately vanish.|Should be invisible!!!!,NO,NO,NO,YES,NO,,,inflictself(~timefreeze_lockout~); var tw = new motion.actuators.SimpleActuator(null|0.01|null); var s = new elements.Skill(~Against all odds_old~); s.script = ~  removestatusself(\~~ + status.type + ~\~|~ + status.value+~);~; tw.onComplete(s.execute|[self|target]); tw.move(); sfx(~_recycle~);,,,,,,,,
timefreeze_lockout,Lockout,skipturn,Any dice that aren't a 1 immediately vanish.,NO,NO,YES,NO,YES,for(mydice in self.dicepool){if(mydice.available() && mydice.basevalue != 1){mydice.animate(~disappear~);};};,,for(mydice in self.dicepool){if(mydice.available() && mydice.basevalue != 1){mydice.animate(~disappear~);};};,for(mydice in self.dicepool){if(mydice.available() && mydice.basevalue != 1){mydice.animate(~disappear~);};};,for(mydice in self.dicepool){if(mydice.available() && mydice.basevalue != 1){mydice.animate(~disappear~|0.2);};};,,,,,,
mf_banish,Banished,banish,<value> of your dice have been banished for this turn.|Get a copy of them next turn.,YES,NO,YES,NO,NO,,,,,,,,,,,
mf_internalbanish,Banished,banish,Whoops! Probably shouldn't be seeing this.,YES,NO,YES,YES,NO,var poss = []; for(mydice in self.dicepool){if(mydice.available()){poss.push(mydice);};}; if(poss.length > 0){var r = rand(poss); inflictself(~stash~+r.basevalue); inflictself(~internalbanish~+r.basevalue);  r.animate(~disappear~); inflictself(~mf_banish~);};,,,,,,,,,,
internalbanish1,Banished,banish,Whoops! Probably shouldn't be seeing this.,YES,NO,YES,YES,NO,,,,,,,,,,,
internalbanish2,Banished,banish,Whoops! Probably shouldn't be seeing this.,YES,NO,YES,YES,NO,,,,,,,,,,,
internalbanish3,Banished,banish,Whoops! Probably shouldn't be seeing this.,YES,NO,YES,YES,NO,,,,,,,,,,,
internalbanish4,Banished,banish,Whoops! Probably shouldn't be seeing this.,YES,NO,YES,YES,NO,,,,,,,,,,,
internalbanish5,Banished,banish,Whoops! Probably shouldn't be seeing this.,YES,NO,YES,YES,NO,,,,,,,,,,,
internalbanish6,Banished,banish,Whoops! Probably shouldn't be seeing this.,YES,NO,YES,YES,NO,,,,,,,,,,,
teleportitis,Teleportitis,jinx,Whenever you take damage[;] gain [dodge]<value> dodge.,YES,NO,YES,NO,NO,,,,,,,,,,inflictself(DODGE); sfx(~_dodge~);,
mf_polevaulted,Pole_Vaulted,dice,hello lurker in the code! This is just a dummy status. It does nothing. Literally nothing.|Excel is autocorrecting this to make me seem more enthusiastic about this. Why are you like this[;] excel. ,NO,NO,NO,YES,NO,,,,,,,,,,,
mimeograph,Calcuduplicate,cog,The next <value> calculations generate a copy of|the dice you roll.,YES,NO,NO,NO,NO,self.setvar(~mimeograph_counter~|self.roll_totaldice);,,,,while(self.getvar(~mimeograph_counter~) < self.roll_totaldice){ self.setvar(~mimeograph_counter~[;] self.getvar(~mimeograph_counter~) + 1); givedice(self.dicepool[self.dicepool.length-1]); removestatusself(status.name|1);}; trace(~boing~); trace(self.getvar(~mimeograph_counter~)); trace(self.roll_totaldice);,,,,,,
mf_diceerrorinstead,Dice_Error_Instead,cog,If you error[;] instead of your equipment erroring out[;]|all of your unused dice disappear.,NO,NO,NO,NO,NO,for(eq in self.equipment){if(!eq.hastag(errorimmune)){eq.addtag(errorimmune); eq.addtag(~diceerrorinstead_added~);};};,,,,,,,,,,
mf_makeerrorimmune,Error_Immune,cog,Random equipment is error immune this turn.,YES,YES,NO,NO,NO,for(x in 0...inflicted_value){var poss = []; for(eq in self.equipment){if(eq.availablethisturn && eq.ready && eq.skillcard == ~~&& !eq.hastag(~errorimmune~)){poss.push(eq);};}; var eq = rand(poss); eq.addtag(~errorimmune~); eq.addtag(~makeerrorimmune_remove~); eq.addtag(~errorimmunecol_~+eq.equipmentcol);  eq.changecolour(~GRAY~); eq.animate(~flashandshake~); };,,,,,,,,,,for(eq in self.equipment){if(eq.hastag(~makeerrorimmune_remove~)){ eq.removetag(~errorimmune~); eq.removetag(~makeerrorimmune_remove~); var col = 0; for(c in 0...12){if(eq.hastag(~errorimmunecol_~+c)){col = c; eq.removetag(~errorimmunecol_~+c);}; }; eq.equipmentcol = col;};};
mf_heartacheshield,Heartache,reduce,Lose zero health from incoming attacks.|Instead[;] lose that much health +<value> in 2 turns.,YES,NO,YES,NO,NO,,,,,,,,,,self.hp+=dmg; jinx(~Heartache~|~lose [heart]%VAR% health~|~Lose [heart]%VAR% health~|~var l = self.limitvalue; target.hp-=%VAR%; sfxdamage(null|%VAR%); sfx(\~_drain\~); if(target.hp < 0){attack(1);}; self.limitvalue = l;~|self|self|2|dmg+status.value); sfx(~_shield~); sfx(~_drain~);,
mf_lifesteel,Lifesteel,shield,Gain [shield]<value> shield with each attack.,YES,NO,NO,NO,NO,,,,,,,,,inflictself(SHIELD|status.value); sfx(~_shield~|~~|0.2);,,
mf_damagetoshield,Damage_To_Shield,shield,Your attacks deal zero damage this turn. Instead[;] all|damage the enemy would take is converted into shield for you.,NO,NO,YES,NO,NO,,,,,,,,,target.hp+=dmg; inflictself(SHIELD|dmg); sfx(~_shield~|~~|0.2);,,
mf_furyeachturn,Fury_Each_Turn,fury,Gain [fury]<value> Fury at the start of your turn.,YES,NO,NO,NO,NO,,,,inflictself(FURY|status.value); sfx(~_fury~);,,,,,,,
mf_voidform,Dice_Up,dice,Get +<value> dice this fight at the end of your turn.,YES,NO,NO,NO,NO,,,,,,,self.extradice+=status.value;,,,,
mf_damagedoublething,Infinite_Form,sword,Deal [sword]<value> damage at the start of your turn[;]|then double the amount of damage.,YES,NO,NO,NO,NO,,,,attack(status.value); sfxdamage(target|status.value); inflictself(status.type|status.value); sfx(~_magic~|~~|0.2);,,,,,,,
mf_malware,Malware,shock,At the start of next turn[;] convert this into [shock]<value> shock.|There's no escaping this virus!,YES,NO,NO,NO,NO,,,inflictself(SHOCK|status.value); var tw = new motion.actuators.SimpleActuator(null|0.01|null); var s = new elements.Skill(~Against all odds_old~); s.script = ~  removestatusself(\~~ + status.type + ~\~|~ + status.value+~);~; tw.onComplete(s.execute|[self|target]); tw.move(); sfx(~_shock~);,,,,,,,,
mf_slapjack,Slapjack,dice,Next turn[;] discarding cards also gives you dice.|Discarding 2 cards gives 1 dice[;] discarding 3 cards gives 2.,NO,NO,NO,NO,NO,,,,Deck.snapstyle = (~dice~); sfx(~_magic~); var tw = new motion.actuators.SimpleActuator(null|0.01|null); var s = new elements.Skill(~Against all odds_old~); s.script = ~  removestatusself(\~~ + status.type + ~\~|~ + status.value+~);~; tw.onComplete(s.execute|[self|target]); tw.move(); sfx(~_shock~);,,,,,,,
mf_burnnextturn,Burn_Next_Turn,fire,At the start of next turn[;] convert this into [fire]<value> burn.,YES,NO,NO,NO,NO,,,inflictself(FIRE|status.value); var tw = new motion.actuators.SimpleActuator(null|0.01|null); var s = new elements.Skill(~Against all odds_old~); s.script = ~  removestatusself(\~~ + status.type + ~\~|~ + status.value+~);~; tw.onComplete(s.execute|[self|target]); tw.move(); sfx(~_fire~);,,,,,,,,
mf_freezenextturn,Freeze_Next_Turn,ice,At the start of next turn[;] convert this into [ice]<value> freeze.,YES,NO,NO,NO,NO,,,inflictself(ICE|status.value); var tw = new motion.actuators.SimpleActuator(null|0.01|null); var s = new elements.Skill(~Against all odds_old~); s.script = ~  removestatusself(\~~ + status.type + ~\~|~ + status.value+~);~; tw.onComplete(s.execute|[self|target]); tw.move(); sfx(~_ice~);,,,,,,,,
mf_capslock,cAPS_lOCK,lock,nEXT TURN[;] LOCK ALL YOUR DICE.,NO,NO,NO,NO,NO,,,inflictself(LOCK|ALL);  sfx(~_lock~); var tw = new motion.actuators.SimpleActuator(null|0.01|null); var s = new elements.Skill(~Against all odds_old~); s.script = ~  removestatusself(\~~ + status.type + ~\~|~ + status.value+~);~; tw.onComplete(s.execute|[self|target]); tw.move();,,,,,,,,
mf_cursenextturn,Freeze_Next_Turn,curse,At the start of next turn[;] convert this into [curse]<value> curse.,YES,NO,NO,NO,NO,,,inflictself(CURSE|status.value); var tw = new motion.actuators.SimpleActuator(null|0.01|null); var s = new elements.Skill(~Against all odds_old~); s.script = ~  removestatusself(\~~ + status.type + ~\~|~ + status.value+~);~; tw.onComplete(s.execute|[self|target]); tw.move(); sfx(~_curse~);,,,,,,,,
mf_secretiveswipe,Swipe,sword,At the start of your turn[;] take [sword]<value> damage per [blind] blind on you.,YES,YES,NO,NO,NO,,,var dmg = getstatusself(BLIND) * status.value; attackself(dmg); sfxdamage(self|dmg); sfx(~_blind~);,,,,,,,,
mf_reducenextturn,Reduce_Next_Turn,reduce,At the start of next turn[;] convert this into [reduce]<value> reduce.,YES,NO,NO,NO,NO,,,inflictself(REDUCE|status.value); var tw = new motion.actuators.SimpleActuator(null|0.01|null); var s = new elements.Skill(~Against all odds_old~); s.script = ~  removestatusself(\~~ + status.type + ~\~|~ + status.value+~);~; tw.onComplete(s.execute|[self|target]); tw.move(); sfx(~_shield~);,,,,,,,,
mf_damagenextturn,Damage_Next_Turn,sword,At the start of next turn[;] take [sword]<value> damage[;]|then remove this status.,YES,NO,NO,NO,NO,,,attackself(status.value); sfxdamage(status.value); var tw = new motion.actuators.SimpleActuator(null|0.01|null); var s = new elements.Skill(~Against all odds_old~); s.script = ~  removestatusself(\~~ + status.type + ~\~|~ + status.value+~);~; tw.onComplete(s.execute|[self|target]); tw.move();,,,,,,,,
