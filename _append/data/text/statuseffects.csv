Name,Displayed As,Symbol,Description,Stacks?,Remove at End Turn?,Remove at Start Turn?,Invisible?,Blocked by Reduce?,Script: When inflicted,Script: On any status infliction,Script: Before Start Turn,Script: On Start Turn,Script: On any equipment use,Script: On any countdown reduce,Script: End Turn,Script: After Combat,Script: On damage inflicted,Script: On damage taken,Script: On status remove
regen0,Spooky_Regen,curse,spoooooooooooooooooky! if you're reading this and aren't poking|around[;] stuff has gone wrong. Contact Jackeea!,YES,NO,YES,YES,NO,,,,,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totalheal = 0; for(i in 0...13) { totalheal += getstatusself(~regen~+i);  removestatusself(~regen~+i|ALL); if(getstatusself(~regen~+(i+1)) > 0){ inflictself(~regen~+i|getstatusself(~regen~+(i+1))); };}; if (totalheal > 0) {  sfx(~_heal~); attackself(-totalheal); };  };,,,,
regen1,Regen,heal,Restore <value> health at the end of your turn. Lasts for 1 turn.|Stacking this increases the healing[;] not duration.,YES,NO,NO,NO,NO,,,,,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totalheal = 0; for(i in 0...13) { totalheal += getstatusself(~regen~+i);  removestatusself(~regen~+i|ALL); if(getstatusself(~regen~+(i+1)) > 0){ inflictself(~regen~+i|getstatusself(~regen~+(i+1))); };}; if (totalheal > 0) {  sfx(~_heal~); attackself(-totalheal); };  };,,,,
regen2,Regen,heal,Restore <value> health at the end of your turn. Lasts for 2 turns.|Stacking this increases the healing[;] not duration.,YES,NO,NO,NO,NO,,,,,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totalheal = 0; for(i in 0...13) { totalheal += getstatusself(~regen~+i);  removestatusself(~regen~+i|ALL); if(getstatusself(~regen~+(i+1)) > 0){ inflictself(~regen~+i|getstatusself(~regen~+(i+1))); };}; if (totalheal > 0) {  sfx(~_heal~); attackself(-totalheal); };  };,,,,
regen3,Regen,heal,Restore <value> health at the end of your turn. Lasts for 3 turns.|Stacking this increases the healing[;] not duration.,YES,NO,NO,NO,NO,,,,,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totalheal = 0; for(i in 0...13) { totalheal += getstatusself(~regen~+i);  removestatusself(~regen~+i|ALL); if(getstatusself(~regen~+(i+1)) > 0){ inflictself(~regen~+i|getstatusself(~regen~+(i+1))); };}; if (totalheal > 0) {  sfx(~_heal~); attackself(-totalheal); };  };,,,,
regen4,Regen,heal,Restore <value> health at the end of your turn. Lasts for 4 turns.|Stacking this increases the healing[;] not duration.,YES,NO,NO,NO,NO,,,,,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totalheal = 0; for(i in 0...13) { totalheal += getstatusself(~regen~+i);  removestatusself(~regen~+i|ALL); if(getstatusself(~regen~+(i+1)) > 0){ inflictself(~regen~+i|getstatusself(~regen~+(i+1))); };}; if (totalheal > 0) {  sfx(~_heal~); attackself(-totalheal); };  };,,,,
regen5,Regen,heal,Restore <value> health at the end of your turn. Lasts for 5 turns.|Stacking this increases the healing[;] not duration.,YES,NO,NO,NO,NO,,,,,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totalheal = 0; for(i in 0...13) { totalheal += getstatusself(~regen~+i);  removestatusself(~regen~+i|ALL); if(getstatusself(~regen~+(i+1)) > 0){ inflictself(~regen~+i|getstatusself(~regen~+(i+1))); };}; if (totalheal > 0) {  sfx(~_heal~); attackself(-totalheal); };  };,,,,
regen6,Regen,heal,Restore <value> health at the end of your turn. Lasts for 6 turns.|Stacking this increases the healing[;] not duration.,YES,NO,NO,NO,NO,,,,,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totalheal = 0; for(i in 0...13) { totalheal += getstatusself(~regen~+i);  removestatusself(~regen~+i|ALL); if(getstatusself(~regen~+(i+1)) > 0){ inflictself(~regen~+i|getstatusself(~regen~+(i+1))); };}; if (totalheal > 0) {  sfx(~_heal~); attackself(-totalheal); };  };,,,,
regen7,Regen,heal,Restore <value> health at the end of your turn. Lasts for 7 turns.|Stacking this increases the healing[;] not duration.,YES,NO,NO,NO,NO,,,,,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totalheal = 0; for(i in 0...13) { totalheal += getstatusself(~regen~+i);  removestatusself(~regen~+i|ALL); if(getstatusself(~regen~+(i+1)) > 0){ inflictself(~regen~+i|getstatusself(~regen~+(i+1))); };}; if (totalheal > 0) {  sfx(~_heal~); attackself(-totalheal); };  };,,,,
regen8,Regen,heal,Restore <value> health at the end of your turn. Lasts for 8 turns.|Stacking this increases the healing[;] not duration.,YES,NO,NO,NO,NO,,,,,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totalheal = 0; for(i in 0...13) { totalheal += getstatusself(~regen~+i);  removestatusself(~regen~+i|ALL); if(getstatusself(~regen~+(i+1)) > 0){ inflictself(~regen~+i|getstatusself(~regen~+(i+1))); };}; if (totalheal > 0) {  sfx(~_heal~); attackself(-totalheal); };  };,,,,
regen9,Regen,heal,Restore <value> health at the end of your turn. Lasts for 9 turns.|Stacking this increases the healing[;] not duration.,YES,NO,NO,NO,NO,,,,,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totalheal = 0; for(i in 0...13) { totalheal += getstatusself(~regen~+i);  removestatusself(~regen~+i|ALL); if(getstatusself(~regen~+(i+1)) > 0){ inflictself(~regen~+i|getstatusself(~regen~+(i+1))); };}; if (totalheal > 0) {  sfx(~_heal~); attackself(-totalheal); };  };,,,,
regen10,Regen,heal,Restore <value> health at the end of your turn. Lasts for 10 turns.|Stacking this increases the healing[;] not duration.,YES,NO,NO,NO,NO,,,,,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totalheal = 0; for(i in 0...13) { totalheal += getstatusself(~regen~+i);  removestatusself(~regen~+i|ALL); if(getstatusself(~regen~+(i+1)) > 0){ inflictself(~regen~+i|getstatusself(~regen~+(i+1))); };}; if (totalheal > 0) {  sfx(~_heal~); attackself(-totalheal); };  };,,,,
regen11,Regen,heal,Restore <value> health at the end of your turn. Lasts for 11 turns.|Stacking this increases the healing[;] not duration.,YES,NO,NO,NO,NO,,,,,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totalheal = 0; for(i in 0...13) { totalheal += getstatusself(~regen~+i);  removestatusself(~regen~+i|ALL); if(getstatusself(~regen~+(i+1)) > 0){ inflictself(~regen~+i|getstatusself(~regen~+(i+1))); };}; if (totalheal > 0) {  sfx(~_heal~); attackself(-totalheal); };  };,,,,
regen12,Regen,heal,Restore <value> health at the end of your turn. Lasts for 12 turns.|Stacking this increases the healing[;] not duration.  (Maximum duration!),YES,NO,NO,NO,NO,,,,,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totalheal = 0; for(i in 0...13) { totalheal += getstatusself(~regen~+i);  removestatusself(~regen~+i|ALL); if(getstatusself(~regen~+(i+1)) > 0){ inflictself(~regen~+i|getstatusself(~regen~+(i+1))); };}; if (totalheal > 0) {  sfx(~_heal~); attackself(-totalheal); };  };,,,,
bleed0,Spooky_Bleed,curse,spoooooooooooooooooky! if you're reading this and aren't poking|around[;] stuff has gone wrong. Contact Jackeea!,YES,YES,NO,YES,YES,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totaldmg  = 0; for(i in 0...13) { totaldmg += getstatusself(~bleed~+i);  removestatusself(~bleed~+i|ALL); if(getstatusself(~bleed~+(i+1)) > 0){ inflictself(~bleed~+i|getstatusself(~bleed~+(i+1))); };}; if (totaldmg > 0) { pierceattackself(totaldmg); sfxdamage(self|totaldmg); };  };,,,,,,,,
bleed1,[red]Bleed[],sword,Lose <value> health at the start of your turn. Lasts for 1 turn.|Stacking this increases the damage[;] not duration.,YES,NO,NO,NO,YES,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totaldmg  = 0; for(i in 0...13) { totaldmg += getstatusself(~bleed~+i);  removestatusself(~bleed~+i|ALL); if(getstatusself(~bleed~+(i+1)) > 0){ inflictself(~bleed~+i|getstatusself(~bleed~+(i+1))); };}; if (totaldmg > 0) { pierceattackself(totaldmg); sfxdamage(self|totaldmg); };  };,,,,,,,,
bleed2,[red]Bleed[],sword,Lose <value> health at the start of your turn. Lasts for 2 turns.|Stacking this increases the damage[;] not duration.,YES,NO,NO,NO,YES,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totaldmg  = 0; for(i in 0...13) { totaldmg += getstatusself(~bleed~+i);  removestatusself(~bleed~+i|ALL); if(getstatusself(~bleed~+(i+1)) > 0){ inflictself(~bleed~+i|getstatusself(~bleed~+(i+1))); };}; if (totaldmg > 0) { pierceattackself(totaldmg); sfxdamage(self|totaldmg); };  };,,,,,,,,
bleed3,[red]Bleed[],sword,Lose <value> health at the start of your turn. Lasts for 3 turns.|Stacking this increases the damage[;] not duration.,YES,NO,NO,NO,YES,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totaldmg  = 0; for(i in 0...13) { totaldmg += getstatusself(~bleed~+i);  removestatusself(~bleed~+i|ALL); if(getstatusself(~bleed~+(i+1)) > 0){ inflictself(~bleed~+i|getstatusself(~bleed~+(i+1))); };}; if (totaldmg > 0) { pierceattackself(totaldmg); sfxdamage(self|totaldmg); };  };,,,,,,,,
bleed4,[red]Bleed[],sword,Lose <value> health at the start of your turn. Lasts for 4 turns.|Stacking this increases the damage[;] not duration.,YES,NO,NO,NO,YES,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totaldmg  = 0; for(i in 0...13) { totaldmg += getstatusself(~bleed~+i);  removestatusself(~bleed~+i|ALL); if(getstatusself(~bleed~+(i+1)) > 0){ inflictself(~bleed~+i|getstatusself(~bleed~+(i+1))); };}; if (totaldmg > 0) { pierceattackself(totaldmg); sfxdamage(self|totaldmg); };  };,,,,,,,,
bleed5,[red]Bleed[],sword,Lose <value> health at the start of your turn. Lasts for 5 turns.|Stacking this increases the damage[;] not duration.,YES,NO,NO,NO,YES,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totaldmg  = 0; for(i in 0...13) { totaldmg += getstatusself(~bleed~+i);  removestatusself(~bleed~+i|ALL); if(getstatusself(~bleed~+(i+1)) > 0){ inflictself(~bleed~+i|getstatusself(~bleed~+(i+1))); };}; if (totaldmg > 0) { pierceattackself(totaldmg); sfxdamage(self|totaldmg); };  };,,,,,,,,
bleed6,[red]Bleed[],sword,Lose <value> health at the start of your turn. Lasts for 6 turns.|Stacking this increases the damage[;] not duration.,YES,NO,NO,NO,YES,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totaldmg  = 0; for(i in 0...13) { totaldmg += getstatusself(~bleed~+i);  removestatusself(~bleed~+i|ALL); if(getstatusself(~bleed~+(i+1)) > 0){ inflictself(~bleed~+i|getstatusself(~bleed~+(i+1))); };}; if (totaldmg > 0) { pierceattackself(totaldmg); sfxdamage(self|totaldmg); };  };,,,,,,,,
bleed7,[red]Bleed[],sword,Lose <value> health at the start of your turn. Lasts for 7 turns.|Stacking this increases the damage[;] not duration.,YES,NO,NO,NO,YES,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totaldmg  = 0; for(i in 0...13) { totaldmg += getstatusself(~bleed~+i);  removestatusself(~bleed~+i|ALL); if(getstatusself(~bleed~+(i+1)) > 0){ inflictself(~bleed~+i|getstatusself(~bleed~+(i+1))); };}; if (totaldmg > 0) { pierceattackself(totaldmg); sfxdamage(self|totaldmg); };  };,,,,,,,,
bleed8,[red]Bleed[],sword,Lose <value> health at the start of your turn. Lasts for 8 turns.|Stacking this increases the damage[;] not duration.,YES,NO,NO,NO,YES,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totaldmg  = 0; for(i in 0...13) { totaldmg += getstatusself(~bleed~+i);  removestatusself(~bleed~+i|ALL); if(getstatusself(~bleed~+(i+1)) > 0){ inflictself(~bleed~+i|getstatusself(~bleed~+(i+1))); };}; if (totaldmg > 0) { pierceattackself(totaldmg); sfxdamage(self|totaldmg); };  };,,,,,,,,
bleed9,[red]Bleed[],sword,Lose <value> health at the start of your turn. Lasts for 9 turns.|Stacking this increases the damage[;] not duration.,YES,NO,NO,NO,YES,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totaldmg  = 0; for(i in 0...13) { totaldmg += getstatusself(~bleed~+i);  removestatusself(~bleed~+i|ALL); if(getstatusself(~bleed~+(i+1)) > 0){ inflictself(~bleed~+i|getstatusself(~bleed~+(i+1))); };}; if (totaldmg > 0) { pierceattackself(totaldmg); sfxdamage(self|totaldmg); };  };,,,,,,,,
bleed10,[red]Bleed[],sword,Lose <value> health at the start of your turn. Lasts for 10 turns.|Stacking this increases the damage[;] not duration.,YES,NO,NO,NO,YES,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totaldmg  = 0; for(i in 0...13) { totaldmg += getstatusself(~bleed~+i);  removestatusself(~bleed~+i|ALL); if(getstatusself(~bleed~+(i+1)) > 0){ inflictself(~bleed~+i|getstatusself(~bleed~+(i+1))); };}; if (totaldmg > 0) { pierceattackself(totaldmg); sfxdamage(self|totaldmg); };  };,,,,,,,,
bleed11,[red]Bleed[],sword,Lose <value> health at the start of your turn. Lasts for 11 turns.|Stacking this increases the damage[;] not duration.,YES,NO,NO,NO,YES,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totaldmg  = 0; for(i in 0...13) { totaldmg += getstatusself(~bleed~+i);  removestatusself(~bleed~+i|ALL); if(getstatusself(~bleed~+(i+1)) > 0){ inflictself(~bleed~+i|getstatusself(~bleed~+(i+1))); };}; if (totaldmg > 0) { pierceattackself(totaldmg); sfxdamage(self|totaldmg); };  };,,,,,,,,
bleed12,[red]Bleed[],sword,Lose <value> health at the start of your turn. Lasts for 12 turns.|Stacking this increases the damage[;] not duration. (Maximum duration!),YES,NO,NO,NO,YES,,,if(self.getvar(~turncounter~) != turn){self.setvar(~turncounter~|turn); var totaldmg  = 0; for(i in 0...13) { totaldmg += getstatusself(~bleed~+i);  removestatusself(~bleed~+i|ALL); if(getstatusself(~bleed~+(i+1)) > 0){ inflictself(~bleed~+i|getstatusself(~bleed~+(i+1))); };}; if (totaldmg > 0) { pierceattackself(totaldmg); sfxdamage(self|totaldmg); };  };,,,,,,,,
pursuit,Pursuit,sword,Increases damage dealt by Pursuit by 3 this turn.,NO,NO,YES,NO,NO,,,,,,,,,,,
pursuitnext,Pursuing,sword,Pursuit deals 3 more damage next turn.,NO,NO,YES,NO,NO,,,,,,,,,,,
bound1,Bound,lock,Sets your first dice to have a value of 1.,YES,YES,NO,NO,YES,,,self.setvar(~bounddice~|0);,var counter = status.value; var bounddice = self.getvar(~bounddice~); if(bounddice == 0){sfx(~_lock~);}; for(mydice in self.dicepool){if(mydice.available()){if(bounddice > 0){bounddice-=1;}else if(counter > 0){counter-=1; mydice.basevalue = 1; mydice.animate(~flashshake~); self.setvar(~bounddice~|self.getvar(~bounddice~)+1);}}};,,,,,,,
bound2,Bound,lock,Sets your first dice to have a value of 2.,YES,YES,NO,NO,YES,,,self.setvar(~bounddice~|0);,var counter = status.value; var bounddice = self.getvar(~bounddice~); if(bounddice == 0){sfx(~_lock~);}; for(mydice in self.dicepool){if(mydice.available()){if(bounddice > 0){bounddice-=1;}else if(counter > 0){counter-=1; mydice.basevalue = 2; mydice.animate(~flashshake~); self.setvar(~bounddice~|self.getvar(~bounddice~)+1);}}};,,,,,,,
bound3,Bound,lock,Sets your first dice to have a value of 3.,YES,YES,NO,NO,YES,,,self.setvar(~bounddice~|0);,var counter = status.value; var bounddice = self.getvar(~bounddice~); if(bounddice == 0){sfx(~_lock~);}; for(mydice in self.dicepool){if(mydice.available()){if(bounddice > 0){bounddice-=1;}else if(counter > 0){counter-=1; mydice.basevalue = 3; mydice.animate(~flashshake~); self.setvar(~bounddice~|self.getvar(~bounddice~)+1);}}};,,,,,,,
bound4,Bound,lock,Sets your first dice to have a value of 4.,YES,YES,NO,NO,YES,,,self.setvar(~bounddice~|0);,var counter = status.value; var bounddice = self.getvar(~bounddice~); if(bounddice == 0){sfx(~_lock~);}; for(mydice in self.dicepool){if(mydice.available()){if(bounddice > 0){bounddice-=1;}else if(counter > 0){counter-=1; mydice.basevalue = 4; mydice.animate(~flashshake~); self.setvar(~bounddice~|self.getvar(~bounddice~)+1);}}};,,,,,,,
bound5,Bound,lock,Sets your first dice to have a value of 5.,YES,YES,NO,NO,YES,,,self.setvar(~bounddice~|0);,var counter = status.value; var bounddice = self.getvar(~bounddice~); if(bounddice == 0){sfx(~_lock~);}; for(mydice in self.dicepool){if(mydice.available()){if(bounddice > 0){bounddice-=1;}else if(counter > 0){counter-=1; mydice.basevalue = 5; mydice.animate(~flashshake~); self.setvar(~bounddice~|self.getvar(~bounddice~)+1);}}};,,,,,,,
bound6,Bound,lock,Sets your first dice to have a value of 6.,YES,YES,NO,NO,YES,,,self.setvar(~bounddice~|0);,var counter = status.value; var bounddice = self.getvar(~bounddice~); if(bounddice == 0){sfx(~_lock~);}; for(mydice in self.dicepool){if(mydice.available()){if(bounddice > 0){bounddice-=1;}else if(counter > 0){counter-=1; mydice.basevalue = 6; mydice.animate(~flashshake~); self.setvar(~bounddice~|self.getvar(~bounddice~)+1);}}};,,,,,,,
petrified1,Petrified,lock,A random item can only be activated with a 1 next turn.,YES,YES,NO,NO,YES,var petrifieditems = self.getvar(~petrifieditems~); var petrifieditemslots = self.getvar(~petrifieditemslots~); trace(petrifieditems); if(petrifieditems == 0 # petrifieditems.length == 0){petrifieditems = []; petrifieditemslots = [];}; self.setvar(~petrifieditems~|petrifieditems); self.setvar(~petrifieditemslots~|petrifieditemslots);,,,var freeslots = [~FREE1~[;]~FREE2~[;]~FREE3~[;]~FREE4~[;]~FREE5~[;]~FREE6~]; var poss = []; var lowpriority = []; var petrifieditems = self.getvar(~petrifieditems~); var petrifieditemslots = self.getvar(~petrifieditemslots~); for(eq in self.equipment){ if(eq.needsdoubles){poss.push(eq);}else if(eq.countdown == 0){ if(eq.getslots()[0].indexOf(~REQUIRE~) > -1){ lowpriority.push(eq); }else{ poss.push(eq); }; }; }; var count = 0; poss = shuffle(poss); if(poss.length == 0){poss = lowpriority; poss = shuffle(poss);}; while(poss.length > 0 && count < status.value){count+=1; if(poss.length == 0){ poss = lowpriority; poss=shuffle(poss); }; var r = poss.pop(); petrifieditems.push(r); petrifieditemslots.push(r.getslots()); var modifier = []; var newslots = []; if(r.getslots()[0] == ~DOUBLES~){newslots = [~REQUIRE1~|~REQUIRE1~];}else{for(s in r.getslots()){ if(freeslots.indexOf(s) > -1){ modifier.push(s); }else{newslots.push(~REQUIRE1~);}; };}; r.changeslots(newslots.concat(modifier)); r.animate(~flashandshake~);}; self.setvar(~petrifieditems~[;]petrifieditems); self.setvar(~petrifieditemslots~[;]petrifieditemslots); sfx(~_weaken~); sfx(~_lock~[;]~~[;]0.3);,,,,,,,var items = self.getvar(~petrifieditems~); trace(items); var slots = self.getvar(~petrifieditemslots~); var x = 0; while(x < items.length){ items[x].changeslots(slots[x]); x = x+1; }; self.setvar(~petrifieditems~[;][]); self.setvar(~petrifieditemslots~[;][]);
petrified2,Petrified,lock,A random item can only be activated with a 2 next turn.,YES,YES,NO,NO,YES,var petrifieditems = self.getvar(~petrifieditems~); var petrifieditemslots = self.getvar(~petrifieditemslots~); trace(petrifieditems); if(petrifieditems == 0 # petrifieditems.length == 0){petrifieditems = []; petrifieditemslots = [];}; self.setvar(~petrifieditems~|petrifieditems); self.setvar(~petrifieditemslots~|petrifieditemslots);,,,var freeslots = [~FREE1~[;]~FREE2~[;]~FREE3~[;]~FREE4~[;]~FREE5~[;]~FREE6~]; var poss = []; var lowpriority = []; var petrifieditems = self.getvar(~petrifieditems~); var petrifieditemslots = self.getvar(~petrifieditemslots~); for(eq in self.equipment){ if(eq.needsdoubles){poss.push(eq);}else if(eq.countdown == 0){ if(eq.getslots()[0].indexOf(~REQUIRE~) > -1){ lowpriority.push(eq); }else{ poss.push(eq); }; }; }; var count = 0; poss = shuffle(poss); if(poss.length == 0){poss = lowpriority; poss = shuffle(poss);}; while(poss.length > 0 && count < status.value){count+=1; if(poss.length == 0){ poss = lowpriority; poss=shuffle(poss); }; var r = poss.pop(); petrifieditems.push(r); petrifieditemslots.push(r.getslots()); var modifier = []; var newslots = []; if(r.getslots()[0] == ~DOUBLES~){newslots = [~REQUIRE2~|~REQUIRE2~];}else{for(s in r.getslots()){ if(freeslots.indexOf(s) > -1){ modifier.push(s); }else{newslots.push(~REQUIRE2~);}; };}; r.changeslots(newslots.concat(modifier)); sfx(~_weaken~); sfx(~_lock~[;]~~[;]0.3); r.animate(~flashandshake~);}; self.setvar(~petrifieditems~[;]petrifieditems); self.setvar(~petrifieditemslots~[;]petrifieditemslots);,,,,,,,var items = self.getvar(~petrifieditems~); var slots = self.getvar(~petrifieditemslots~); var x = 0; while(x < items.length){ items[x].changeslots(slots[x]); x = x+1; }; self.setvar(~petrifieditems~[;][]); self.setvar(~petrifieditemslots~[;][]);
petrified3,Petrified,lock,A random item can only be activated with a 3 next turn.,YES,YES,NO,NO,YES,var petrifieditems = self.getvar(~petrifieditems~); var petrifieditemslots = self.getvar(~petrifieditemslots~); trace(petrifieditems); if(petrifieditems == 0 # petrifieditems.length == 0){petrifieditems = []; petrifieditemslots = [];}; self.setvar(~petrifieditems~|petrifieditems); self.setvar(~petrifieditemslots~|petrifieditemslots);,,,var freeslots = [~FREE1~[;]~FREE2~[;]~FREE3~[;]~FREE4~[;]~FREE5~[;]~FREE6~]; var poss = []; var lowpriority = []; var petrifieditems = self.getvar(~petrifieditems~); var petrifieditemslots = self.getvar(~petrifieditemslots~); for(eq in self.equipment){ if(eq.needsdoubles){poss.push(eq);}else if(eq.countdown == 0){ if(eq.getslots()[0].indexOf(~REQUIRE~) > -1){ lowpriority.push(eq); }else{ poss.push(eq); }; }; }; var count = 0; poss = shuffle(poss); if(poss.length == 0){poss = lowpriority; poss = shuffle(poss);}; while(poss.length > 0 && count < status.value){count+=1; if(poss.length == 0){ poss = lowpriority; poss=shuffle(poss); }; var r = poss.pop(); petrifieditems.push(r); petrifieditemslots.push(r.getslots()); var modifier = []; var newslots = []; if(r.getslots()[0] == ~DOUBLES~){newslots = [~REQUIRE3~|~REQUIRE3~];}else{for(s in r.getslots()){ if(freeslots.indexOf(s) > -1){ modifier.push(s); }else{newslots.push(~REQUIRE3~);}; };}; r.changeslots(newslots.concat(modifier)); sfx(~_weaken~); sfx(~_lock~[;]~~[;]0.3); r.animate(~flashandshake~);}; self.setvar(~petrifieditems~[;]petrifieditems); self.setvar(~petrifieditemslots~[;]petrifieditemslots);,,,,,,,var items = self.getvar(~petrifieditems~); var slots = self.getvar(~petrifieditemslots~); var x = 0; while(x < items.length){ items[x].changeslots(slots[x]); x = x+1; }; self.setvar(~petrifieditems~[;][]); self.setvar(~petrifieditemslots~[;][]);
petrified4,Petrified,lock,A random item can only be activated with a 4 next turn.,YES,YES,NO,NO,YES,var petrifieditems = self.getvar(~petrifieditems~); var petrifieditemslots = self.getvar(~petrifieditemslots~); trace(petrifieditems); if(petrifieditems == 0 # petrifieditems.length == 0){petrifieditems = []; petrifieditemslots = [];}; self.setvar(~petrifieditems~|petrifieditems); self.setvar(~petrifieditemslots~|petrifieditemslots);,,,var freeslots = [~FREE1~[;]~FREE2~[;]~FREE3~[;]~FREE4~[;]~FREE5~[;]~FREE6~]; var poss = []; var lowpriority = []; var petrifieditems = self.getvar(~petrifieditems~); var petrifieditemslots = self.getvar(~petrifieditemslots~); for(eq in self.equipment){ if(eq.needsdoubles){poss.push(eq);}else if(eq.countdown == 0){ if(eq.getslots()[0].indexOf(~REQUIRE~) > -1){ lowpriority.push(eq); }else{ poss.push(eq); }; }; }; var count = 0; poss = shuffle(poss); if(poss.length == 0){poss = lowpriority; poss = shuffle(poss);}; while(poss.length > 0 && count < status.value){count+=1; if(poss.length == 0){ poss = lowpriority; poss=shuffle(poss); }; var r = poss.pop(); petrifieditems.push(r); petrifieditemslots.push(r.getslots()); var modifier = []; var newslots = []; if(r.getslots()[0] == ~DOUBLES~){newslots = [~REQUIRE4~|~REQUIRE4~];}else{for(s in r.getslots()){ if(freeslots.indexOf(s) > -1){ modifier.push(s); }else{newslots.push(~REQUIRE4~);}; };}; r.changeslots(newslots.concat(modifier)); sfx(~_weaken~); sfx(~_lock~[;]~~[;]0.3); r.animate(~flashandshake~);}; self.setvar(~petrifieditems~[;]petrifieditems); self.setvar(~petrifieditemslots~[;]petrifieditemslots);,,,,,,,var items = self.getvar(~petrifieditems~); var slots = self.getvar(~petrifieditemslots~); var x = 0; while(x < items.length){ items[x].changeslots(slots[x]); x = x+1; }; self.setvar(~petrifieditems~[;][]); self.setvar(~petrifieditemslots~[;][]);
petrified5,Petrified,lock,A random item can only be activated with a 5 next turn.,YES,YES,NO,NO,YES,var petrifieditems = self.getvar(~petrifieditems~); var petrifieditemslots = self.getvar(~petrifieditemslots~); trace(petrifieditems); if(petrifieditems == 0 # petrifieditems.length == 0){petrifieditems = []; petrifieditemslots = [];}; self.setvar(~petrifieditems~|petrifieditems); self.setvar(~petrifieditemslots~|petrifieditemslots);,,,var freeslots = [~FREE1~[;]~FREE2~[;]~FREE3~[;]~FREE4~[;]~FREE5~[;]~FREE6~]; var poss = []; var lowpriority = []; var petrifieditems = self.getvar(~petrifieditems~); var petrifieditemslots = self.getvar(~petrifieditemslots~); for(eq in self.equipment){ if(eq.needsdoubles){poss.push(eq);}else if(eq.countdown == 0){ if(eq.getslots()[0].indexOf(~REQUIRE~) > -1){ lowpriority.push(eq); }else{ poss.push(eq); }; }; }; var count = 0; poss = shuffle(poss); if(poss.length == 0){poss = lowpriority; poss = shuffle(poss);}; while(poss.length > 0 && count < status.value){count+=1; if(poss.length == 0){ poss = lowpriority; poss=shuffle(poss); }; var r = poss.pop(); petrifieditems.push(r); petrifieditemslots.push(r.getslots()); var modifier = []; var newslots = []; if(r.getslots()[0] == ~DOUBLES~){newslots = [~REQUIRE5~|~REQUIRE5~];}else{for(s in r.getslots()){ if(freeslots.indexOf(s) > -1){ modifier.push(s); }else{newslots.push(~REQUIRE5~);}; };}; r.changeslots(newslots.concat(modifier)); sfx(~_weaken~); sfx(~_lock~[;]~~[;]0.3); r.animate(~flashandshake~);}; self.setvar(~petrifieditems~[;]petrifieditems); self.setvar(~petrifieditemslots~[;]petrifieditemslots);,,,,,,,var items = self.getvar(~petrifieditems~); var slots = self.getvar(~petrifieditemslots~); var x = 0; while(x < items.length){ items[x].changeslots(slots[x]); x = x+1; }; self.setvar(~petrifieditems~[;][]); self.setvar(~petrifieditemslots~[;][]);
petrified6,Petrified,lock,A random item can only be activated with a 6 next turn.,YES,YES,NO,NO,YES,var petrifieditems = self.getvar(~petrifieditems~); var petrifieditemslots = self.getvar(~petrifieditemslots~); trace(petrifieditems); if(petrifieditems == 0 # petrifieditems.length == 0){petrifieditems = []; petrifieditemslots = [];}; self.setvar(~petrifieditems~|petrifieditems); self.setvar(~petrifieditemslots~|petrifieditemslots);,,,var freeslots = [~FREE1~[;]~FREE2~[;]~FREE3~[;]~FREE4~[;]~FREE5~[;]~FREE6~]; var poss = []; var lowpriority = []; var petrifieditems = self.getvar(~petrifieditems~); var petrifieditemslots = self.getvar(~petrifieditemslots~); for(eq in self.equipment){ if(eq.needsdoubles){poss.push(eq);}else if(eq.countdown == 0){ if(eq.getslots()[0].indexOf(~REQUIRE~) > -1){ lowpriority.push(eq); }else{ poss.push(eq); }; }; }; var count = 0; poss = shuffle(poss); if(poss.length == 0){poss = lowpriority; poss = shuffle(poss);}; while(poss.length > 0 && count < status.value){count+=1; if(poss.length == 0){ poss = lowpriority; poss=shuffle(poss); }; var r = poss.pop(); petrifieditems.push(r); petrifieditemslots.push(r.getslots()); var modifier = []; var newslots = []; if(r.getslots()[0] == ~DOUBLES~){newslots = [~REQUIRE6~|~REQUIRE6~];}else{for(s in r.getslots()){ if(freeslots.indexOf(s) > -1){ modifier.push(s); }else{newslots.push(~REQUIRE6~);}; };}; r.changeslots(newslots.concat(modifier)); sfx(~_weaken~); sfx(~_lock~[;]~~[;]0.3); r.animate(~flashandshake~);}; self.setvar(~petrifieditems~[;]petrifieditems); self.setvar(~petrifieditemslots~[;]petrifieditemslots);,,,,,,,var items = self.getvar(~petrifieditems~); var slots = self.getvar(~petrifieditemslots~); var x = 0; while(x < items.length){ items[x].changeslots(slots[x]); x = x+1; }; self.setvar(~petrifieditems~[;][]); self.setvar(~petrifieditemslots~[;][]);
cache,Cached,dice,Store <value> dice for next turn.,YES,NO,YES,NO,NO,,,,,,,,,,,
lightstatus,Enlightened,dice,Get [yellow]<value>[] extra dice next turn.,YES,NO,YES,NO,NO,,,,,,,,,,,
permafrost,Permafrost,ice,Receive [ice]<value> freeze next turn.,YES,NO,NO,NO,YES,,,,,,,,,,,
lamppost1,Lamppost,dice,Get a free [yellow]1[] next turn.,NO,NO,YES,NO,NO,,,,,,,,,,,
lamppost2,Lamppost,dice,Get a free [yellow]2[] next turn.,NO,NO,YES,NO,NO,,,,,,,,,,,
lamppost3,Lamppost,dice,Get a free [yellow]3[] next turn.,NO,NO,YES,NO,NO,,,,,,,,,,,
lamppost4,Lamppost,dice,Get a free [yellow]4[] next turn.,NO,NO,YES,NO,NO,,,,,,,,,,,
lamppost5,Lamppost,dice,Get a free [yellow]5[] next turn.,NO,NO,YES,NO,NO,,,,,,,,,,,
lamppost6,Lamppost,dice,Get a free [yellow]6[] next turn.,NO,NO,YES,NO,NO,,,,,,,,,,,
tickly,Tickled,dice,Get <value> free [yellow]1[]s next turn.,YES,NO,YES,NO,NO,,,,,,,,,,,
lifesteal,Lifesteal,heal,Your attacks deal [sword]<value> less damage[;] but|heal you for [heal]<value> health.,YES,YES,NO,NO,NO,,,,,,,,,var amt = getstatusself(~lifesteal~); if(dmg < amt){attackself(-dmg); target.hp+=dmg;}else{attackself(-amt); target.hp+=amt; }; sfx(~_heal~);,,
mechanical_lantern,Mechanicalantern,dice,Get <value> free dice next turn.,YES,NO,YES,NO,NO,,,,,,,,,,,
ratchet,Ratchet,cog,Increases the range on MAX or MIN|equipment by <value> this turn.,YES,YES,NO,NO,NO,,,,,,,,,,,
dynamo,Beam_Power,cog,Beam weapons[;] such as [red]Focus Beam[][;] [yellow]Solar Beam[][;]|[blue]Lunar Beam[] and [orange]Terra Beam[][;] all deal [cog]<value> damage.,YES,NO,NO,NO,NO,self.setvar(~dynamo~|status.value);,,,,,,,,,,self.setvar(~dynamo~|status.value);
gemstoneboost,Boosted,gold,Gem Generators create upgraded gems this turn.,NO,YES,NO,NO,NO,,,,,,,,,,,
gemstoneamount,Crystallized,gold,Gem Generators create <value> more gems this turn.,YES,YES,NO,NO,NO,,,,,,,,,,,
batted,Battered,dice,Enemy caught the dice you batted!|They get <value> more dice next turn.,YES,YES,NO,NO,NO,,,,,,,,,,,
lego,Lego,cog,Gain [thorns]999 thorns at the end of this turn.,NO,NO,NO,NO,NO,,,,,,,,,,,
lego2,Lego,cog,Gain [thorns]999999 thorns at the end of this turn.,NO,NO,NO,NO,NO,,,,,,,,,,,
helium,Inflated,jinx,Your dice are... floaty!|More helium means faster floatiness.,YES,YES,NO,NO,YES,,,,,,,,,,,
whelm,Whelmed,sword,Whelm deals <value> more damage.,YES,NO,NO,NO,NO,,,,,,,,,,,
polymorph,Polymorph,potion,A random item is permanently replaced|with another random item.,YES,YES,NO,NO,,,,,var poss = []; for(eq in self.equipment){if(!eq.hastag(~skillcard~) && !eq.hastag(~powercard~)){poss.push(eq);};}; poss = shuffle(poss); var count = 0; while(count < status.value && count < poss.length){var replaceequip = poss[count]; count+=1; var newequip; if(replaceequip.size == 1){newequip = rand(getequipmentlist(null|[~small~]|[~excludefromrandomlists~|~skillcard~|~robotonly~|~witchonly~|~powercard~]));}else{newequip = rand(getequipmentlist(null|[~large~]|[~excludefromrandomlists~|~skillcard~|~robotonly~|~witchonly~|~powercard~]));}; trace(newequip); var  x = replaceequip.x; var y = replaceequip.y; if(replaceequip.upgraded){replaceequip.create(newequip|true|false|true);}else{replaceequip.create(newequip);} replaceequip.x = x; replaceequip.y = y; replaceequip.animate(~flashandshake~); replaceequip.changeslots(replaceequip.getslots());  }; sfx(~jester_discard~);,,,,,,,
polymorphall,Polymorph_All,potion,ALL items get permanently replaced with random items.,NO,YES,NO,NO,,,,,var poss = []; for(eq in self.equipment){if(!eq.hastag(~skillcard~) && !eq.hastag(~powercard~)){poss.push(eq);};}; poss = shuffle(poss); var count = 0; while(count < poss.length){var replaceequip = poss[count]; count+=1; var newequip; if(replaceequip.size == 1){newequip = rand(getequipmentlist(null|[~small~]|[~excludefromrandomlists~|~skillcard~|~robotonly~|~witchonly~|~powercard~]));}else{newequip = rand(getequipmentlist(null|[~large~]|[~excludefromrandomlists~|~skillcard~|~robotonly~|~witchonly~|~powercard~]));}; trace(newequip); var  x = replaceequip.x; var y = replaceequip.y; if(replaceequip.upgraded){replaceequip.create(newequip|true|false|true);}else{replaceequip.create(newequip);} replaceequip.x = x; replaceequip.y = y; replaceequip.animate(~flashandshake~); replaceequip.changeslots(replaceequip.getslots()); }; sfx(~jester_discard~);,,,,,,,
nerfed,Nerfed,jinx,Items are harder to play.|Weakening an item resets it.,YES,NO,NO,NO,YES,,,,,,,,,,,
reaper,Reaper,heal,Your next attack heals you for the damage done.,YES,NO,NO,NO,NO,,,,,,,,,attackself(-dmg); sfx(~_heal~); removestatusself(status.name|1);,,
essence_base,Base_Essence,sword,Does nothing. When invoked:|Take [sword]4 damage for each Base Essence.,YES,NO,NO,NO,NO,,,,,,,,,,,
essence_fire,Flame_Essence,fire,Does nothing. When invoked:|Receive [fire]1 burn for each Flame Essence.,YES,NO,NO,NO,NO,,,,,,,,,,,
essence_ice,Frost_Essence,ice,Does nothing. When invoked:|Receive [ice]1 freeze for each Frost Essence.,YES,NO,NO,NO,NO,,,,,,,,,,,
essence_shock,Air_Essence,shock,Does nothing. When invoked:|Receive [shock]1 shock for each Air Essence.,YES,NO,NO,NO,NO,,,,,,,,,,,
essence_weaken,Earth_Essence,weaken,Does nothing. When invoked:|Receive [weaken]1 weaken for each Earth Essence.,YES,NO,NO,NO,NO,,,,,,,,,,,
essence_poison,Toxic_Essence,poison,Does nothing. When invoked:|Receive [poison]2 poison for each Toxic Essence.,YES,NO,NO,NO,NO,,,,,,,,,,,
essence_dark,Dark_Essence,curse,Does nothing. When invoked:|Receive a bad status ([curse]Curse[;] [lock]Lock[;] [shock]Stun),YES,NO,NO,NO,NO,,,,,,,,,,,
mf_stun,Stun,shock,Random equipment is disabled for the turn.,YES,YES,NO,NO,YES,,,,var goodeq = []; for(eq in self.equipment){ if(eq.availablethisturn){ goodeq.push(eq); }; }; goodeq = shuffle(goodeq); var s = getstatusself(~mf_stun~); while(goodeq.length > 0 && s > 0){ s-=1; var r = goodeq.pop(); r.availablethisturn = false;  r.unavailabledetails = [~Stunned~]; r.animate(~flashandshake~); }; sfx(~_shock~);,,,,,,,
alternate_mf_stun,Stun?,shock,Lose a dice next turn.,YES,YES,NO,NO,YES,,,,for(mydice in self.dicepool){trace(mydice.basevalue);};,,,,,,,
nothing,Nothing,curse,Does absolutely nothing.,NO,YES,NO,NO,NO,,,,,,,,,,,
alternate_nothing,Nothing?,curse,Does absolutely nothing[;] but with a question mark.,NO,YES,NO,NO,NO,,,,,,,,,,,
grace,Grace,heart,At the start of your turn[;] if your health is less than|your Grace ([heart]<value>[])[;] swap your health and your Grace.,YES,NO,NO,NO,NO,,,var grace = getstatus(~grace~); var diff = grace - self.hp; if(diff > 0){ pierceattackself(-diff); sfx(~_heal~); sfx(~_survive~); removestatus(~grace~[;]diff); };,,,,,,,,
healaftercombat,Regeneration,heal,After combat[;] recover [heal]<value> health.|Doesn't trigger if you flee.,YES,NO,NO,NO,NO,,,,,,,,if(!flee){attackself(-getstatusself(~healaftercombat~));};,,,
poisonovertime,Toxins,poison,At the end of your turn[;] receive [poison]1 poison.|Lasts for <value> turns.,YES,NO,NO,NO,YES,,,,,,,removestatusself(status.name|1); inflictself(POISON); sfx(~_poison~);,,,,
revolver,Ammunition,sword,After this reaches 6[;] reduce this by 6|and deal [sword]18 damage.,YES,NO,NO,NO,NO,while(status.value >= 6){removestatusself(status.name|6); attack(18); sfxdamage(target|18);};,,,,,,,,,,
shielddown,Shield_Down,potion,At the start of your turn[;] lose [shield]<value> shield.,YES,NO,NO,NO,YES,,,,removestatusself(SHIELD|status.value);,,,,,,,
hallucinate,Hallucinate,confuse,Equipment slots are randomised.,NO,YES,NO,NO,NO,,,,,,,,,,,
hallucinate_upgraded,Hallucinate+,confuse,Equipment slots are randomised. No [quote]Needs X[quote] slots will appear.,NO,YES,NO,NO,NO,,,,,,,,,,,
hallucinate_downgraded,Hallucinate-,confuse,Equipment slots are randomised to random [quote]Needs X[quote] slots.,NO,YES,NO,NO,NO,,,,,,,,,,,
mf_skipturn,Skip_Turn,confuse,Skips your next turn.,YES,NO,NO,NO,YES,,,,,,,,,,,
mf_bonusturn,Time_Loop,potion,At the start of your next turn[;] gain an extra turn.,NO,NO,NO,YES,NO,,,,,,,,,,,
mf_suffocate,Suffocate,lock,At the start of your turn[;] lock any blinded dice.,NO,NO,YES,NO,YES,,,,,,,,,,,
mf_healnextturn,Heal_Next_Turn,heart,At the start of next turn[;] recover [heart]<value> health.,YES,NO,NO,NO,NO,,,,,,,,,,,
mf_cursecarryover,Curse_Next_Turn,curse,At the start of next turn[;] convert this into [curse]<value> curse.,YES,NO,NO,NO,YES,,,,,,,,,,,
mf_magma,Magma,fire,At the start of your turn[;] take [fire]<value> damage.|Doesn't disappear after your turn.,YES,NO,NO,NO,YES,,,,attackself(status.value|FIRE); sfx(~_fire~);,,,,,,,
mf_shiver,Shiver,ice,At the start of your turn[;] take [ice]<value> damage.|Doesn't disappear after your turn.,YES,NO,NO,NO,YES,,,,attackself(status.value|ICE); sfx(~_ice~);,,,,,,,
alternate_mf_magma,Magma?,fire,At the start of your turn[;] take [fire]2x<value> damage[;]|then reduce how much [fire]Magma? you have by half.,YES,NO,NO,NO,YES,,,,attackself(status.value*2|FIRE); removestatusself(status.name|(status.value+1)/2); sfx(~_fire~);,,,,,,,
alternate_mf_shiver,Shiver?,ice,At the start of your turn[;] take 2x [ice]<value> damage[;]|then reduce how much [ice]Shiver? you have by half.,YES,NO,NO,NO,YES,,,,attackself(status.value*2|ICE); removestatusself(status.name|(status.value+1)/2); sfx(~_ice~);,,,,,,,
slowregen,Rejuvenation,heal,Restore [heal]1 health every 2 seconds[;] for <value> seconds.,YES,NO,NO,NO,NO,,,,,,,,,,,
nospellbook,No_Spellbook,curse,Spellbook is disabled for the rest of this battle.|Rely on your remaining spells!,NO,NO,NO,NO,NO,,,self.getskillcard().ready=false;,self.getskillcard().animate(~curse~);,,,,,,,
mf_poweredup,Powered_Up!,star,You[quote]ve used [star]<value> [yellow]Power Bolts[] this turn.,YES,YES,NO,NO,NO,,,,,,,,,,,
envenomate,Envenomate,poison,Your next attack that deals [sword]<value> or less damage|instead has its damage converted into poison.,YES,YES,NO,NO,NO,,,,,,,,,if(dmg <= getstatusself(~envenomate~)){inflict(POISON|dmg); sfx(~_poison~); target.hp+=dmg;}; removestatusself(status.type|ALL);,,
criticalhit,Critical_Hit,star,Your attacks have a <value>% chance to deal double damage.,YES,YES,NO,NO,NO,,,,,,,,,if(chance(status.value)){ target.hp = target.hp-dmg; sfx(~_fury~); self.textparticle(~Critical Hit!~); };,,
criticalhit_baseamount,Critical_Hit_Internal,curse,Whoops! Probably shouldn't be seeing this.,YES,YES,NO,YES,NO,if(getstatusself(~luck+~) > 0){inflictself(~criticalhit~|100);}else if(getstatusself(~luck~) > 0){inflictself(~criticalhit~|status.value * 2);}else{inflictself(~criticalhit~|status.value);};,if(inflicted_type == ~luck+~){inflictself(~criticalhit~|100); sfx(~_fury~);}; if(inflicted_type == ~luck~){inflictself(~criticalhit~|getstatusself(~criticalhit~)); sfx(~_fury~);}; if(getstatusself(~criticalhit~) > 100){removestatusself(~criticalhit~|ALL); inflictself(~criticalhit~|100);};,,,,,,,,,
mendingregen,Mending,heal,Your next <value> attacks grant up to 3 turns of [heal] Regen.|(Regen heals you for 1 health/turn),YES,YES,NO,NO,NO,,,,,,,,,if(dmg > 3){inflictself(~regen3~);}else if(dmg > 0){inflictself(~regen~+dmg);} sfx(~_cure~); removestatusself(status.type|1);,,
weakennextturn,Weaken_Next_Turn,weaken,Receive [weaken]<value> weaken for the enemy's turn.,YES,YES,NO,NO,NO,,,,,,,inflict(~dummyweaken~|status.value);,,,,
dummyweaken,Weaken_Enemy_Next_Turn,weaken,Whoops! Probably shouldn't be seeing this.,YES,YES,NO,NO,NO,,,inflict(WEAKEN|status.value);,,,,,,,,
mf_weakeneachturn,Weaken_Each_Turn,weaken,Receive [weaken]<value> weaken each turn.,YES,NO,NO,NO,NO,inflict(WEAKEN|status.value);,,,,,,inflict(~dummyweaken~|status.value);,,,,
wingsoflight,Wings_Of_Light,heart,Whenever you take damage this turn[;] heal [heal]<value> health per|turn[;] for turns equal to the damage (maximum: 5),YES,NO,YES,NO,NO,,,,,,,,,,if(dmg > 5){inflictself(~regen5~|status.value);}else if(dmg > 0){inflictself(~regen~+dmg|status.value);} sfx(~_cure~);,
